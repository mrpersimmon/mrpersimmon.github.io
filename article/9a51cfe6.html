<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo1/logo-180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo1/logo-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo1/logo-16.png">
  <link rel="mask-icon" href="/images/logo1/logo-512.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">
<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=JetBrains+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.mrpersimmon.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="二叉树解题思维分两类：  是否可以通过遍历一遍二叉树得到答案？ 如果可以，用一个 traverse 函数配合外部变量来实现，这叫 「遍历」的思维模式。 是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？ 如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。  无论哪种思维模式，我们都需要思考： 如果单独抽出一个二叉树节点，它需要做什么事情？">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树与递归的框架思维「详解版」">
<meta property="og:url" content="https://www.mrpersimmon.top/article/9a51cfe6.html">
<meta property="og:site_name" content="柿子先生的博客">
<meta property="og:description" content="二叉树解题思维分两类：  是否可以通过遍历一遍二叉树得到答案？ 如果可以，用一个 traverse 函数配合外部变量来实现，这叫 「遍历」的思维模式。 是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？ 如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。  无论哪种思维模式，我们都需要思考： 如果单独抽出一个二叉树节点，它需要做什么事情？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/1.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/2.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/tree.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/3.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/2-20230407201904428.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/tree1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/1-20230408150000724.jpeg">
<meta property="article:published_time" content="2023-04-07T02:23:33.000Z">
<meta property="article:modified_time" content="2023-04-29T09:22:50.030Z">
<meta property="article:author" content="柿子先生">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="算法框架">
<meta property="article:tag" content="二叉树">
<meta property="article:tag" content="递归">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/1.jpeg">


<link rel="canonical" href="https://www.mrpersimmon.top/article/9a51cfe6.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.mrpersimmon.top/article/9a51cfe6.html","path":"article/9a51cfe6.html","title":"二叉树与递归的框架思维「详解版」"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>二叉树与递归的框架思维「详解版」 | 柿子先生的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="柿子先生的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">柿子先生的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我有半亩良田，种有柿子两棵</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">26</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">16</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">二叉树的重要性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">1.1.</span> <span class="nav-text">快速排序和归并排序的本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%BB%E8%BE%91%E5%92%8C%E6%A1%86%E6%9E%B6"><span class="nav-number">1.2.</span> <span class="nav-text">快速排序的逻辑和框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E9%80%BB%E8%BE%91"><span class="nav-number">1.2.1.</span> <span class="nav-text">算法逻辑</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6"><span class="nav-number">1.2.2.</span> <span class="nav-text">代码框架</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%BB%E8%BE%91%E5%92%8C%E6%A1%86%E6%9E%B6"><span class="nav-number">1.3.</span> <span class="nav-text">归并排序的逻辑和框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E9%80%BB%E8%BE%91-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">算法逻辑</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6-1"><span class="nav-number">1.3.2.</span> <span class="nav-text">代码框架</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">深入理解前中后序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.</span> <span class="nav-text">三个问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%A1%86%E6%9E%B6"><span class="nav-number">2.1.1.</span> <span class="nav-text">二叉树遍历框架</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="nav-number">2.1.2.</span> <span class="nav-text">前中后序位置的特殊性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E5%8F%89%E6%A0%91%E6%B2%A1%E6%9C%89%E4%B8%AD%E5%BA%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.1.3.</span> <span class="nav-text">多叉树没有中序位置的原因</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">3.</span> <span class="nav-text">两种解题思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E7%9C%8B%E4%B8%A4%E7%A7%8D%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">3.1.</span> <span class="nav-text">从二叉树的最大深度看两种解题思路</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BE%97%E5%87%BA%E7%AD%94%E6%A1%88"><span class="nav-number">3.1.1.</span> <span class="nav-text">遍历二叉树得出答案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E8%A7%A3%E9%97%AE%E9%A2%98%E5%BE%97%E5%87%BA%E7%AD%94%E6%A1%88"><span class="nav-number">3.1.2.</span> <span class="nav-text">分解问题得出答案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">3.2.</span> <span class="nav-text">二叉树的前序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BE%97%E5%87%BA%E7%AD%94%E6%A1%88-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">遍历二叉树得出答案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E8%A7%A3%E9%97%AE%E9%A2%98%E5%BE%97%E5%87%BA%E7%AD%94%E6%A1%88-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">分解问题得出答案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E7%9B%AE%E7%9A%84%E9%80%9A%E7%94%A8%E6%80%9D%E8%80%83%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.3.</span> <span class="nav-text">二叉树题目的通用思考过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E7%89%B9%E6%AE%8A%E4%B9%8B%E5%A4%84"><span class="nav-number">4.</span> <span class="nav-text">后序位置的特殊之处</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%89%8D%E5%BA%8F%E4%BD%8D%E7%BD%AE"><span class="nav-number">4.1.</span> <span class="nav-text">中序和前序位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E4%BD%8D%E7%BD%AE"><span class="nav-number">4.2.</span> <span class="nav-text">后序位置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.1.</span> <span class="nav-text">两个简单问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">4.2.2.</span> <span class="nav-text">二叉树的直径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">5.</span> <span class="nav-text">层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6-2"><span class="nav-number">5.1.</span> <span class="nav-text">代码框架</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">6.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="柿子先生" src="/images/logo1/avatar.png">
  <p class="site-author-name" itemprop="name">柿子先生</p>
  <div class="site-description" itemprop="description">凡事有交代|件件有着落|事事有回应</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mrpersimmon/mrpersimmon.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mrpersimmon&#x2F;mrpersimmon.github.io" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2218443280@qq.com" title="E-Mail → mailto:2218443280@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>


      
<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
<div class="widget-wrap">
    <div id="myCanvasContainer" class="widget tagcloud">
        <canvas width="250" height="250" id="resCanvas" style="width:100%">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AlgorithmFramework/" rel="tag">AlgorithmFramework</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BinarySearchAndSort/" rel="tag">BinarySearchAndSort</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedList/" rel="tag">LinkedList</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NowCoder-TOP101/" rel="tag">NowCoder-TOP101</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/" rel="tag">RPC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Simulation/" rel="tag">Simulation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/" rel="tag">String</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Trie/" rel="tag">Trie</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Two-Pointers/" rel="tag">Two Pointers</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TwoPointers/" rel="tag">TwoPointers</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/index/" rel="tag">index</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%9B%E5%AE%A2-TOP101/" rel="tag">牛客-TOP101</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/" rel="tag">算法框架</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a><span class="tag-list-count">3</span></li></ul>
        </canvas>
    </div>
</div>

        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>



    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.mrpersimmon.top/article/9a51cfe6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo1/avatar.png">
      <meta itemprop="name" content="柿子先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子先生的博客">
      <meta itemprop="description" content="凡事有交代|件件有着落|事事有回应">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="二叉树与递归的框架思维「详解版」 | 柿子先生的博客">
      <meta itemprop="description" content>
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          二叉树与递归的框架思维「详解版」
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-07 10:23:33" itemprop="dateCreated datePublished" datetime="2023-04-07T10:23:33+08:00">2023-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-29 17:22:50" itemprop="dateModified" datetime="2023-04-29T17:22:50+08:00">2023-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">二叉树</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">算法框架</span></a>
        </span>
    </span>

  
<!--
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
-->
    <span class="post-meta-break"></span>
<!--
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
-->
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>21 分钟</span>
    </span>
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>

</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><strong>二叉树解题思维分两类：</strong></p>
<ol type="1">
<li><p><strong>是否可以通过遍历一遍二叉树得到答案？</strong></p>
<p>如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫
「遍历」的思维模式。</p></li>
<li><p><strong>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？</strong></p>
<p>如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p></li>
</ol>
<p><strong>无论哪种思维模式，我们都需要思考：</strong></p>
<p><strong>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？</strong>其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</p>
<p>本文解决了如下题目：</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">力扣第
104 题「二叉树的最大深度」</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">力扣第
144 题「二叉树的前序遍历」</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/diameter-of-binary-tree">力扣第
543 题「二叉树的直径」</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">剑指
Offer 第 55 题 「二叉树的深度」</a></p>
<span id="more"></span>
<h3 id="二叉树的重要性">二叉树的重要性</h3>
<h4 id="快速排序和归并排序的本质">快速排序和归并排序的本质</h4>
<ul>
<li><p><strong>快速排序：二叉树前序遍历</strong></p></li>
<li><p><strong>归并排序：二叉树后序遍历</strong></p></li>
</ul>
<h4 id="快速排序的逻辑和框架">快速排序的逻辑和框架</h4>
<h5 id="算法逻辑">算法逻辑</h5>
<p>若要对 <code>nums[lo...hi]</code>
进行排序，我们先找一个<strong>分界点 p</strong>，通过交换元素使得
<code>nums[lo...p-1]</code> 都 <code>&lt;= nums[p]</code>，且
<code>nums[p+1...hi]</code> 都 <code>&gt; nums[p]</code>，然后递归地去
<code>nums[lo...p-1]</code> 和 <code>nums[p+1...hi]</code>
中寻找新的分界点，最后这个数组就被排序了。</p>
<h5 id="代码框架">代码框架</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：排序 nums[lo...hi]</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="comment">/****** 前序遍历位置 ******/</span></span><br><span class="line">    <span class="comment">// 通过交换元素构建分界点 p</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line">    <span class="comment">/************************/</span></span><br><span class="line">    </span><br><span class="line">    sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>先构造分界点，然后去左右子数组构造分界点，这不就是一个二叉树的<u>前序遍历</u>吗？</strong></p>
<h4 id="归并排序的逻辑和框架">归并排序的逻辑和框架</h4>
<h5 id="算法逻辑-1">算法逻辑</h5>
<p>若要对 <code>nums[lo...hi]</code> 进行排序，我们先对
<code>nums[lo...mid]</code> 进行排序，再对 <code>nums[mid+1...hi]</code>
排序，最后把这两个有序的子数组合并成整个数组就排好序了。</p>
<h5 id="代码框架-1">代码框架</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：排序 nums[lo...hi]</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + ((hi - lo) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 排序 nums[lo...mid]</span></span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    <span class="comment">// 排序 nums[mid+1...hi]</span></span><br><span class="line">    sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/****** 后序位置 ******/</span></span><br><span class="line">    <span class="comment">// 合并 nums[lo...mid] 和 nums[mid+1...hi]</span></span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">    <span class="comment">/********************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>先对左右子数组进行排序，然后合并（类似合并有序链表的逻辑），这不就是<u>二叉树的后序遍历</u>嘛，同时也是<u>分治算法</u>思想的体现呀。</strong></p>
<p>二叉树的算法思想运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树问题。</p>
<hr>
<h3 id="深入理解前中后序">深入理解前中后序</h3>
<h4 id="三个问题">三个问题</h4>
<p>先思考 3 个问题：</p>
<ol type="1">
<li>二叉树的前中后序遍历是什么？仅仅是三个顺序不同的 List 吗？</li>
<li>后序遍历有什么特殊之处？</li>
<li>多叉树为什么没有中序遍历？</li>
</ol>
<h5 id="二叉树遍历框架">二叉树遍历框架</h5>
<p>首先，看一下二叉树的遍历框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先不管所谓前中后序，单看 traverse 函数，它在做什么事情？</p>
<p>其实，<strong>它就是一个能够遍历二叉树所有节点的一个函数</strong>，和遍历数组或者链表本质上没有区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代遍历数组</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历数组</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == arr.length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    traverse(arr, i + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代遍历单链表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历单链表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    traverse(head.next);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单链表和数组的遍历可以是迭代的，也可以是递归地，<strong>二叉树这种结构无非就是二叉链表</strong>，由于没办法简单改写成迭代形式，所以一般说<strong>二叉树的遍历框架都是指递归的形式</strong>。</p>
<p>值得注意的是，<strong>只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。</strong></p>
<p><strong>所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，</strong>那么进一步，你把代码写在不同位置，代码执行的时机也不同：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/1.jpeg" alt="代码执行时机" style="zoom:50%;"></p>
<p><strong>如果让你<u>倒序打印</u>一条单链表上所有节点的值，你如何实现？</strong></p>
<p>如果使用递归来实现的话，可以利用后序位置来操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    traverse(head.next);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    print(head.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上面那张图，可以知道这段代码之所以能实现倒序打印单链表的本质是：<strong>利用递归的堆栈帮你实现了倒序遍历的效果。</strong></p>
<h5 id="前中后序位置的特殊性">前中后序位置的特殊性</h5>
<p>回到二叉树，二叉树不过多了一个中序位置罢了。</p>
<p><strong>前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点</strong>，绝不仅仅是三个顺序不同的
List。</p>
<ul>
<li>前序位置的代码在刚刚进入一个二叉树节点的时候执行；</li>
<li>后序位置的代码在将要离开一个二叉树节点的时候执行；</li>
<li>中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。</li>
</ul>
<p>注意文中的用词，一直在强调<strong>前中后序「位置」</strong>，就是要和常说的前中后序「遍历」有所区别：我们可以在前序位置写代码，往一个
List
里面塞元素，那最后得到的就是前序遍历结果；但并不是说你就不可以写更复杂的代码做更复杂的事。</p>
<p>画成图，前中后序三个位置在二叉树上的样子如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/2.jpeg" alt="二叉树的前中后序的位置" style="zoom:30%;"></p>
<p>可以发现，<strong>每个节点都有唯一属于自己的前中后序位置</strong>，因此前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点。</p>
<h5 id="多叉树没有中序位置的原因">多叉树没有中序位置的原因</h5>
<p>这也就是<strong>为什么多叉树没有中序位置</strong>，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。</p>
<p><strong>二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。</strong></p>
<p>图论算法将二叉树的遍历框架扩展到了图，并以遍历为基础实现了图论的各种经典算法。</p>
<hr>
<h3 id="两种解题思路">两种解题思路</h3>
<p>二叉树题目的递归解法可以分两类思路，<strong>第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，</strong>这两类思路分别对应着<strong>回溯算法核心框架</strong>和<strong>动态规划核心框架</strong>。</p>
<blockquote>
<p><strong>函数命名习惯</strong></p>
<p>二叉树中用<strong>遍历思路解题</strong>时函数签名一般是<code>void traverse(...)</code>，没有返回值，靠更新外部变量来计算结果。而用<strong>分解问题思路解题</strong>时函数名根据该函数具体功能而定，而且一般会有返回值，返回值是子问题的计算结果。</p>
<p>与此对应，在<strong>回溯算法核心框架</strong>中给出的函数签名一般也是没有返回值的
<code>void backtrack(...)</code>。而在<strong>动态规划核心框架</strong>中给出的函数签名是带有返回值的
<code>dp</code> 函数。这也说明了它俩和二叉树之间有联系。</p>
</blockquote>
<h4 id="从二叉树的最大深度看两种解题思路">从二叉树的最大深度看两种解题思路</h4>
<p>牛客<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.nowcoder.com/practice/8a2b2bf6c19b4f23a9bdb9b233eefa73">BM28
二叉树的最大深度</a>，所谓最大深度就是树的根节点到最远叶子节点的最长路径上的节点数，比如输入这棵二叉树，算法应该返回
3：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/tree.jpg" alt="二叉树的最大深度" style="zoom:70%;"></p>
<h5 id="遍历二叉树得出答案">遍历二叉树得出答案</h5>
<p>思路：遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度，这就是遍历二叉树计算答案的思路。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录最大深度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 记录遍历到的节点的深度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树遍历框架</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    depth++;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 到达叶子节点，更新最大深度</span></span><br><span class="line">        res = Math.max(res, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    depth--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么需要再前序位置增加 <code>depth</code>，在后序位置减小
<code>depth</code> ?</p>
<p>因为前面说了，前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，<code>depth</code>
记录当前递归到的节点深度，你把 <code>traverse</code>
理解成在二叉树上游走的一个指针，所以当然要这样维护。</p>
<p>至于对 <code>res</code>
的更新，你放到前中后序位置都可以，只要保证在进入节点之后，离开节点之前（即
<code>depth</code> 自增之后，自减之前）就行了。</p>
<h5 id="分解问题得出答案">分解问题得出答案</h5>
<p>当然，你也很容易发现一棵二叉树的最大深度可以通过子树的最大深度推导出来，这就是<strong>分解问题计算答案的思路</strong>。</p>
<p>解法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 利用定义，计算左右子树的最大深度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="comment">// 整棵树的最大深度 = 左右子树的最大深度取最大值 + 1 (根节点自己)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要明确递归函数的定义，这个解法也不难理解，但<strong>为什么主要的代码逻辑集中在后序位置？</strong></p>
<p>因为这个思路正确的核心在于，你确实可以通过子树的最大深度推导出原树的深度，所以当然要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置。</p>
<h4 id="二叉树的前序遍历">二叉树的前序遍历</h4>
<p>如果理解了最大深度这个问题的两种思路，那么我们在回头看看最基本的二叉树前中后序遍历，比如获取前序遍历结果。</p>
<h5 id="遍历二叉树得出答案-1">遍历二叉树得出答案</h5>
<p>最熟悉的解法就是用「遍历」的思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 返回前序遍历结果</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">preorderTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二叉树遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    res.add(root);</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分解问题得出答案-1">分解问题得出答案</h5>
<p>那么，能否使用「分解问题」的思路，来计算前序遍历的结果？</p>
<p>换句话说，不要用像 <code>traverse</code>
这样的辅助函数和任何外部变量，单纯用题目给的
<code>preorderTraverse</code> 函数递归解题。</p>
<p>我们知道前序遍历的特点是，根节点的值排在首位，接着是左子树的前序遍历结果，最后是右子树的遍历结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/3.jpeg" alt="img" style="zoom:50%;"></p>
<p>那么，这样就可以分解问题了。</p>
<p><strong>一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 +
右子树的前序遍历结果。</strong></p>
<p>所以，就可以这样实现前序遍历算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">preorderTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 前序遍历的结果，root.val 在第一个</span></span><br><span class="line">    res.add(root.val);</span><br><span class="line">    <span class="comment">// 利用函数定义，后面接着左子树的前序遍历结果</span></span><br><span class="line">    res.addAll(preorderTraverse(root.left));</span><br><span class="line">    <span class="comment">// 利用函数定义，后面接着右子树的前序遍历结果</span></span><br><span class="line">    res.addAll(preorderTraverse(root.right));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序和后序遍历也是类似的，只要把 <code>add(root.val)</code>
放到中序和后序对应的位置就行了。</p>
<p><strong>这个解法短小精干，但为什么不常见呢？</strong></p>
<p>一个原因是<strong>这个算法的复杂度不好把控</strong>，比较依赖语言特性。</p>
<p>Java 的话，无论 ArrayList 还是 LinkedList，<code>addAll</code>
方法的复杂度都是 <span class="math inline">\(O(N)\)</span>，所以总体的最坏时间复杂度会达到
<span class="math inline">\(O(N^2)\)</span>，除非你自己实现一个复杂度为
<span class="math inline">\(O(1)\)</span> 的 <code>addAll</code>
方法，底层用链表是可以做到的，因为多条链表只要简单的指针操作就能连接起来。</p>
<p>当然，最主要的原因还是因为教科书上从来没这么教过...</p>
<h5 id="二叉树题目的通用思考过程">二叉树题目的通用思考过程</h5>
<p>综上，遇到一道二叉树的题目时的通用思考过程是：</p>
<ol type="1">
<li><strong>是否可以通过遍历一遍二叉树得到答案？</strong>如果可以，用一个
traverse 函数配合外部变量来实现。</li>
<li><strong>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？</strong>如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。</li>
<li><strong>无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。</strong></li>
</ol>
<hr>
<h3 id="后序位置的特殊之处">后序位置的特殊之处</h3>
<h4 id="中序和前序位置">中序和前序位置</h4>
<p>说后序位置之前，先简单说下中序和前序。</p>
<p><strong>中序位置主要用在 BST 场景中，你完全可以把 BST
的中序遍历认为是遍历有序数组。</strong></p>
<p>前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。</p>
<h4 id="后序位置">后序位置</h4>
<p>你可以发现，<strong>前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/2-20230407201904428.jpeg" alt="二叉树的前中后序位置" style="zoom:30%;"></p>
<p>这不奇怪，因为本文开头就说了前序位置是刚刚进入节点时刻，后序位置是即将离开节点的时刻。</p>
<p>但这里面大有玄妙，<strong>这意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。</strong></p>
<h5 id="两个简单问题">两个简单问题</h5>
<p>举一个具体例子，现在给你一棵二叉树，有两个简单问题：</p>
<ol type="1">
<li>如果把根节点看作第 1 层，如何打印出每一个节点所在的层数？</li>
<li>如何打印出每个节点的左右子树各有多少节点？</li>
</ol>
<p>解决第一个问题的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;节点 %s 在第 %d 层&quot;</span>, root, level);</span><br><span class="line">    traverse(root.left, level + <span class="number">1</span>);</span><br><span class="line">    traverse(root.right, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">traverse(root, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>解决第二个问题的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树，返回这棵二叉树的节点总数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> count(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> count(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点&quot;</span>,</span><br><span class="line">            root, leftCount, rightCount);</span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个问题的根本区别在于：<strong>一个节点在第几层，你从根节点遍历过来的过程就能顺带记录，用递归函数的参数就能传递下去；而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚，然后通过递归函数的返回值拿到答案。</strong></p>
<p>结合这两个简单的问题，可以发现后序位置的特点，<strong>只有后序位置才能通过返回值获取子树的信息。</strong></p>
<p>那么换句话说，<strong>一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。</strong></p>
<h5 id="二叉树的直径">二叉树的直径</h5>
<p>下面看一下<a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/diameter-of-binary-tree">力扣第 543
题「二叉树的直径」</a>，计算一棵二叉树的最长直径长度。</p>
<p>所谓二叉树的直径长度，就是任意两个节点之间的路径长度。最长直径并不一定要穿过根节点，比如下面这棵二叉树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/tree1.png" alt="二叉树的直径" style="zoom:60%;"></p>
<p>它的最长直径是 3，即 [4,2,1,3]，[4,2,1,9] 或者 [5,2,1,3]
这几条直径的长度。</p>
<p>解决这题的关键在于，<strong>每一条二叉树的直径长度，就是一个节点的左右子树的最大深度之和。</strong></p>
<p>现在让我求整棵树中的最长直径，那直截了当的思路就是遍历整棵树中的每个节点，然后通过每个节点的左右子树的最大深度算出每个节点的直径，最后把所有直径求个最大值即可。</p>
<p>最大深度的算法已经实现过了，上述思路可以写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录最大直径的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDiameter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 对每个节点计算直径，求最大直径</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历二叉树</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 对每个节点计算直径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">myDiameter</span> <span class="operator">=</span> leftMax + rightMax;</span><br><span class="line">        <span class="comment">// 更新全局最大直径</span></span><br><span class="line">        maxDiameter = Math.max(maxDiameter, myDiameter);</span><br><span class="line">        </span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算二叉树的最大深度</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个解法是正确的，但是运行时间很长，原因也很明显，<code>traverse</code>
遍历每个节点的时候还会调用递归函数 <code>maxDepth</code>，而
<code>maxDepth</code> 是要遍历子树的所有节点的，所以最坏时间复杂度是
<span class="math inline">\(O(N^2)\)</span>。</p>
<p>这就出现了刚才探讨的情况，<strong>前序位置无法获取子树信息，所以只能让每个节点调用
<code>maxDepth</code> 函数去算子树的深度。</strong></p>
<p>那如何优化？</p>
<p>我们应该把计算直径的逻辑放在后序位置，准确说应该是放在
<code>maxDepth</code> 的后序位置，因为 <code>maxDepth</code>
的后序位置是知道左右子树的最大深度的。</p>
<p>优化后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录最大直径的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDiameter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 后序位置，顺便计算最大直径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">myDiameter</span> <span class="operator">=</span> leftMax + rightMax;</span><br><span class="line">        maxDiameter = Math.max(maxDiameter, myDiameter);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次，时间复杂度只有 <code>maxDepth</code> 函数的 <span class="math inline">\(O(N)\)</span> 了。</p>
<p>讲到这里，照应一下前文：<strong>遇到子树问题，首先想到的是给函数设置返回值，然后在后序位置做文章。</strong></p>
<blockquote>
<p>请思考一下，运用后序遍历的题目使用的是「遍历」思路还是「分解问题」思路？</p>
<p>使用了「分解问题」的思路。因为当前节点接收并利用了子树返回的信息，这就意味着你把原问题分解成了当前节点
+ 左右子树的子问题。</p>
</blockquote>
<hr>
<h3 id="层序遍历">层序遍历</h3>
<h4 id="代码框架-2">代码框架</h4>
<p><strong>二叉树题型主要用来培养递归思维，而层序遍历属于迭代遍历</strong>，也比较简单，下面是代码框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树的根节点，层序遍历这棵二叉树</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的 while 循环和 for 循环分管从上到下和从左到右的遍历：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/1-20230408150000724.jpeg" alt="层序遍历" style="zoom:40%;"></p>
<p><strong>BFS
算法框架</strong>就是从二叉树的层序遍历扩展出来的，常用于<strong>求无权图的最短路径</strong>问题。</p>
<p>当然，这个框架还可以灵活修改，题目不需要记录层数（步数）时，可以去掉上述框架中的
for 循环，比如 Dijkstra 算法中计算加权图的最短路径问题，详细探讨了 BFS
算法的扩展。</p>
<p>值得一提的是，有些很明显需要层序遍历技巧的二叉树的题目，也可以用递归遍历的方式去解决，而且技巧性会更强，非常考察你对前中后序的把控。</p>
<p>比如说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// root 视为第 0 层</span></span><br><span class="line">        traverse(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 前序位置，看看是否已经存储 depth 层的节点了</span></span><br><span class="line">        <span class="keyword">if</span> (res.size() &lt;= depth) &#123;</span><br><span class="line">            <span class="comment">// 第一次进入 depth 层</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序位置，在 depth 层添加 root 节点的值</span></span><br><span class="line">        res.get(depth).add(root.val);</span><br><span class="line">        traverse(root.left, depth + <span class="number">1</span>);</span><br><span class="line">        traverse(root.right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种思路从结果上说确实可以得到层序遍历结果，但其本质还是二叉树的前序遍历，或者说
DFS 的思路，而不是层序遍历，或者说 BFS
的思路。因为这个解法是依赖前序遍历自顶向下，自左向右的顺序特点得到了正确的结果。</p>
<p><strong>这个解法更像是从左到右的「列序遍历」，而不是自顶向下的「层序遍历」。</strong>所以对于计算最小距离的场景，这个解法完全等同于
DFS 算法，没有 BFS 算法的性能的优势。</p>
<h3 id="参考资料">参考资料</h3>
<ol type="1">
<li>labuladong 的算法小抄</li>
<li>牛客网</li>
<li>力扣网</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 算法</a>
              <a href="/tags/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/" rel="tag"><i class="fa fa-tag"></i> 算法框架</a>
              <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag"><i class="fa fa-tag"></i> 二叉树</a>
              <a href="/tags/%E9%80%92%E5%BD%92/" rel="tag"><i class="fa fa-tag"></i> 递归</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/article/47bbfc8b.html" rel="prev" title="二分查找与排序">
                  <i class="fa fa-chevron-left"></i> 二分查找与排序
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/article/ebfb7429.html" rel="next" title="二叉树与递归的框架思维「浓缩版」">
                  二叉树与递归的框架思维「浓缩版」 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">柿子先生</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">58k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:30</span>
  </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      本站总访问量
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>

</div>
<div class="busuanzi-count">
<!--
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      本站总访问量
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
-->
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/mrpersimmon/mrpersimmon.github.io" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="external nofollow noopener noreferrer" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"mrpersimmon","repo":"mrpersimmon.github.io","client_id":"6a0869694b7c91ac193b","client_secret":"8387d0b555f020af83f68ab339fdd8a150b1d541","admin_user":"mrpersimmon","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"6e3a1abb3ffb58f423a5b59fd4cb1545"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
