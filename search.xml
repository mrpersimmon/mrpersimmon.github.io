<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTP &amp; RPC</title>
    <url>/article/60a9ecdf.html</url>
    <content><![CDATA[<p>对外一般使用 HTTP 协议，内部集群和微服务之间采用 RPC 协议。HTTP 和
RPC 的服务发现方式基本一致；HTTP1.1 和 RPC 都会建立 TCP 长连接，RPC
还会建个连接池，而一些编程语言的网络库也会给 HTTP 加个连接池；HTTP1.1
采用 Json 来序列化结构体，而 RPC 会使用 Protobuf
等体积更小的序列化协议，并且无需考虑复杂的浏览器行为，性能更高。当然
HTTP2 的性能更好，比如 gRPC 的底层就直接使用 HTTP2。</p>
<span id="more"></span>
<h1 id="http-rpc">HTTP &amp; RPC</h1>
<p>RPC 本质上不算是协议，而是一种调用方式，只有 gRPC 这样的具体实现才是协议，是实现了 RPC 调用的协议。RPC 的实现方式不一定得基于 TCP 协议，还可以基于 HTTP 协议来实现。一般来说，<strong>对外一般使用 HTTP 协议，而内部集群和微服务之间采用 RPC 协议进行通讯。</strong></p>
<p>下面从<strong>服务发现</strong>、<strong>底层连接形式</strong>和<strong>传输内容</strong>来说一下两者的区别。</p>
<p><strong>1、服务发现（找到目标服务器的 IP 地址和端口）</strong></p>
<p>HTTP 使用 DNS 服务去找到服务的域名。RPC 使用专门的中间服务去保存服务名和 IP 信息，如 Consul、Etcd、Redis，甚至 CoreDNS。双方差距不大。</p>
<p><strong>2、底层连接形式</strong></p>
<p>HTTP1.1 在建立底层 TCP 连接后会一直保持这个连接（Keep Alive），之后的请求和响应都会复用这条连接。RPC 不仅会建立 TCP 长连接，还会再建个<strong>连接池</strong>，<strong>用完放回去，下次再复用</strong>。而一些编程语言（Go）的网络库会给 HTTP 加个连接池，所以双方差距不大。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202308080148406.png"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>3、传输内容</strong></p>
<p>基于 TCP 传输的消息，由<strong>消息头 Header</strong> 和<strong>消息体 Body</strong> 组成。Header 用于标记一些特殊信息，如<strong>消息体长度</strong>。Body 用于存放真正传输的内容，结构体需要使用序列化和反序列化进行传输。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202308080149385.png"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>HTTP1.1 使用 Json 来序列化 Body，Header 和 Body 内容冗余。</strong></p>
<p><strong>RPC 可定制，采用体积更小的 Protobuf 或其它序列化协议来序列化 Body，不需要像 HTTP 那样考虑各种浏览器行为，性能更好。</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202308080148410.png"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202308080148413.png"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>HTTP2 的性能比很多 RPC 协议更好，gRPC 的底层直接使用 HTTP2。</strong></p>
<p>HTTP2 是 2015 年出来的，而很多公司内部 RPC 已经跑了很久，就没必要去换了，除非为了性能而进行更换。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>8k+字！详细解读二分查找变体问题，与 bug 说再见！</title>
    <url>/article/3f91e5ac.html</url>
    <content><![CDATA[<h1 id="引言">引言</h1>
<p>Donald E.Knuth 在《计算机程序设计艺术》的第 3
卷《排序和查找》中说到：“尽管第一个二分查找算法于 1946
年出现，然而第一个完全正确的二分查找算法实现直到 1962 年才出现。”</p>
<p>二分查找算法的最基础应用场景：在<strong>无重复元素</strong>的<strong>有序数组</strong>中，查找目标值的元素。这种场景的代码实现确实比较简单。但是，二分查找算法的变形问题可就不那么简单了。</p>
<p>比如，在<strong>有重复元素</strong>的<strong>有序数组</strong>中，<a
href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">查找第一个值等于目标值的元素、查找最后一个值等于目标值的元素</a>、<strong>查找第一个大于等于目标值的元素</strong>、<strong>查找最后一个小于等于目标值的元素</strong>。你可以先自己试试看能否解决这些问题。</p>
<p>二分查找算法经常出现在大厂面试中的手撕环节，考察过该题目的公司有：拼多多、美团、腾讯、阿里巴巴、百度、华为等大厂。</p>
<p>我相信，友好的讨论交流会让彼此快速进步！文章难免有疏漏之处，十分欢迎大家在评论区中批评指正。</p>
<p>读完本篇文章，你将能轻松解决如下问题：</p>
<ul>
<li><a
href="https://leetcode.cn/problems/binary-search/">二分查找(力扣704)</a></li>
<li>如何用最省内存的方式实现千万级数据的快速查找？</li>
<li><a
href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置(力扣34)</a></li>
<li><a
href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">在排序数组中查找数字I(剑指Offer53-I)</a></li>
<li>如何快速定位出一个 IP 地址归属地？</li>
<li>展厅如何限制入场人数？</li>
<li><a
href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组（力扣33）</a></li>
</ul>
<p>为了照顾完全不了解二分查找算法的新同学，文章将从最基本的二分查找算法讲起，探讨四种变体问题，给出两个实际应用问题，最后给出几个难易程度不同的算法问题用于练习。</p>
<span id="more"></span>
<h1 id="查找一个数基础用法">查找一个数（基础用法）</h1>
<h2 id="具体描述">具体描述</h2>
<p>在无重复元素的有序数组中查找一个数，如果存在，返回其索引，否则返回
-1。</p>
<h2 id="举个例子">举个例子🌰</h2>
<p>我们举一个例子，一个有序数组 <code>nums</code>，元素值分别是
<code>[8, 10, 12, 16, 20]</code>，我们想要找到目标值 <code>target</code>
为 10。我们如何使用二分搜索来做呢？</p>
<p>因为数组是有序的，我们<strong>每次取查找区间
<code>[left, right]</code> 中点的元素值与目标值比大小</strong>。</p>
<p>如图所示，<code>left</code> 是查找区间的左边界，<code>right</code>
是查找区间的右边界，红色方格为答案，应返回其索引 1。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305212350401.png" /></p>
<p>下面，我来解释一下图中的流程：</p>
<ol type="1">
<li><code>nums[mid] &gt; target</code>，中点值大于目标值，说明<strong>中点值右边的值都比目标值大</strong>，因此目标值一定在左半区间
<code>[left, mid - 1]</code>。<code>right</code> 要左移，即
<code>right = mid - 1</code>，<code>right</code> 将指向索引 1
，<code>mid</code> 将指向索引 0。</li>
<li><code>nums[mid] &lt; target</code>，中点值小于目标值，说明中点值左边的值都比目标值小，因此目标值一定在右半区间
<code>[mid + 1, right]</code>。<code>left</code> 要右移，即
<code>left = mid + 1</code>，<code>left</code> 将指向索引
1，<code>mid</code> 也将指向索引 1。</li>
<li><code>nums[mid] == target</code>，找到目标值，直接返回
<code>mid</code> 索引为 1。</li>
</ol>
<p>图中没有演示的一种情况是，<strong>如果遍历完整个数组后都没找到目标值，那就说明没找到，返回
-1。</strong></p>
<h2 id="参考代码">参考代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 查找区间 [left, right]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; </span><br><span class="line">        <span class="comment">// 计算 mid，详解见下方注解</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123; <span class="comment">// 找到目标值，返回索引</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123; <span class="comment">// 查找区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)&#123; <span class="comment">// 查找区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为了清楚地展示所有细节，我将区间移动的所有情况都用 else if
写明，如果是第一次接触二分查找的同学，建议和我一样写清楚哦。</strong></p>
<blockquote>
<p><strong>Tips!</strong></p>
<p>有同学可能会有疑问，为什么计算 <code>mid</code> 不是使用
<code>mid = (left + right) / 2</code> 呢？</p>
<p>这是因为 <code>mid = (left + right) / 2</code> 有溢出的风险，如果
<code>left</code> 和 <code>right</code>
的值都特别大的话，两者相加就可能溢出。</p>
<p>改进的方法就是使用
<code>mid = left + (right - left) / 2</code>，更进一步的改进，从性能的角度考虑，位运算比除法更快，<strong>除以
2</strong> 的运算与位运算 <code>&gt;&gt; 1</code> 是等价的，因此最终写成
<code>mid = left + ((right - left) &gt;&gt; 1)</code>。</p>
</blockquote>
<h2 id="梳理细节">梳理细节</h2>
<p><strong>1. 查找区间：</strong><code>[left, right]</code>，因为
<code>right</code> 初始化时是
<code>nums.length - 1</code>，即最后一个元素的索引。</p>
<p><strong>2.
停止查找的条件：</strong><code>nums[mid] == target</code>，找到目标值即停止。如果没有找到，while
循环终止，并返回 -1。</p>
<p><strong>3.
循环终止条件：</strong>。<code>while (left &lt;= right)</code>
的循环终止条件是 <code>left == right + 1</code> 时，写成区间形式就是
<code>[right + 1, right]</code>，此时<strong>查找区间为空</strong>，说明不存在目标元素，直接返回
<code>-1</code> 即可。</p>
<p><strong>4. 区间移动：</strong>在查找区间为 <code>[left, right]</code>
时，若索引 <code>mid</code> 上的元素不是要找的 <code>target</code>
时，要去 <code>[left, mid - 1]</code> 或 <code>[mid + 1, right]</code>
区间上搜索，<strong>因为 mid
已经被搜索过了，应当从搜索区间中删除</strong>。</p>
<h2 id="时间复杂度">时间复杂度</h2>
<p><span class="math inline">\(O(logn)\)</span></p>
<p>对长度为 n
的数组进行二分，每次查找后数据量都会缩小为原来的一半，也就是会除以
2。最坏情况下，直到查找区间被缩小为空，才停止。</p>
<p>被查找区间的大小变化为：<span class="math inline">\(n\)</span>，<span
class="math inline">\(n/2\)</span>，<span
class="math inline">\(n/4\)</span>，...，<span
class="math inline">\(n/2^k\)</span>，这是一个等比数列，当 <span
class="math inline">\(n/2^k = 1\)</span> 时，<span
class="math inline">\(k\)</span>
的值就是缩小区间的次数，每一次缩小操作只涉及中点元素和目标值的大小比较，所以，经过了
<span class="math inline">\(k\)</span> 次区间缩小操作，时间复杂度就是
<span class="math inline">\(O(k)\)</span>， 而 <span
class="math inline">\(k = log_2n\)</span>，所以时间复杂度为 <span
class="math inline">\(O(logn)\)</span>。</p>
<p>O(logn) 是对数时间复杂度，这种复杂度十分高效。试想一下，如果二分查找
32 次，可以查找多长的有序数组中的目标值？<span
class="math inline">\(2^{32} = 4,294,967,296\)</span>，在 42
亿多的数据量中，只需查找 32
次就能确定目标值的索引，是不是很惊人，是不是很大胆！</p>
<h2 id="算法局限性">算法局限性</h2>
<p><strong>1. 二分查找只能在顺序表结构中，也就是数组。</strong></p>
<p>二分查找需要数据结构<strong>支持下标随机访问元素</strong>。因此，链表这样的结构是不可以的，数组按照下标随机访问元素的时间复杂度是
O(1)，而链表随机访问元素的时间复杂度是
O(n)，因此如果使用链表来存储数据，再使用二分查找，那么时间复杂度就会特别高。</p>
<p><strong>2. 二分查找要求数据必须有序。</strong></p>
<p><strong>二分查找适用于插入、删除不频繁，一次排序后多次查找的场景中。</strong>如果数据集合的数据经常发生变动，想要使用二分查找，就必须维护数据集合的有序性，这个维护成本非常高。</p>
<p><strong>3. 数据量过大不适合二分查找。</strong></p>
<p>诶嘿，是不是觉得很新奇，不是说数据量越大，二分查找的优越性越大吗？这就不得不提数组这个数据结构了。</p>
<p>二分查找底层依赖数组这种数据结构，而<strong>数组为了支持随机访问的特性，要求内存空间必须连续</strong>。比如，我们有
1GB 大小的数据，如果希望用数组来存储，那么就需要 1GB
的连续内存空间。</p>
<p>注意「连续」内存空间，如果你有 2GB
内存空间剩余，但是这些空间都是零散的，没有连续的 1GB
大小内存空间，那照样无法申请 1GB
大小的数组。而我们的二分查找是需要数组来支撑的。因此，如果数据量多到无法用数组来存储，那就无法使用二分查找了！</p>
<h1
id="如何用最省内存的方式实现千万级数据的快速查找">🔥如何用最省内存的方式实现千万级数据的快速查找？</h1>
<h2 id="情景描述">情景描述</h2>
<p>假设我们有 1000 万个整数数据，每个数据占 8
字节，最大内存空间占用不得超过
100MB。<strong>请你设计一种数据结构和算法，可以快速查找某个整数在这 1000
万的数据中的索引？</strong></p>
<h2 id="实现方案">实现方案</h2>
<p>我们可以将所有数据存储在数组中，然后将这些整数数据进行排序，再利用二分查找算法就可以快速查找想要的数据了。</p>
<p>我们要确定一下是否超出了内存限制，首先数据占用了约 78MB （<span
class="math display">\[10,000,000 \times 8B \div 1024 = 78.125
MB\]</span>）的空间，数组这种结构除了存储数据本身之外，不需要额外存储其他信息，因此符合内存限制。</p>
<p><strong>我们知道散列表、二叉树也是支持快速查找的，大部分情况下，二分查找可以解决的问题，它们俩都可以解决。</strong><u>但是，这道题不行，因为这两种结构存储
1000 万的数据，100MB
内存肯定存不下。</u>而<strong>二分查找底层依赖的数组，除了存储数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式</strong>，所以刚好能在限定的内存大小下解决这个问题。</p>
<h1
id="查找第一个等于目标值的元素变体1">查找第一个等于目标值的元素（变体1）</h1>
<h2 id="具体描述-1">具体描述</h2>
<p>在一个有序数组中，存在多个大小为 <code>target</code>
值的元素，请找到第一个等于目标值的元素（可以看作<strong>所有重复元素的左边界</strong>），如果存在，返回其索引，否则返回
-1。</p>
<h2 id="举个例子-1">举个例子🌰</h2>
<p>俗话说，万变不离其宗。这道变体的解决思路和基础用法的思路是一致的，只不过在一些细节之处发生了变化。我们还是从一个例子入手。</p>
<p>我们以有序数组 <code>[1, 3, 4, 5, 5, 5, 5, 5, 9]</code>，目标值
<code>target</code> 为 5 为例进行讲解。</p>
<p>如图所示，<code>left</code> 是查找区间的左边界，<code>right</code>
是查找区间的右边界，红色方格为答案，应返回其索引 3。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305221100386.png" /></p>
<ol type="1">
<li><p><code>nums[mid] == target</code>，一开始我们就在数组中找到了和
<code>target</code> 相等的元素，可以直接返回索引 4 吗？</p>
<p>当然不可以啦，我们要找的是第一个 5，应该返回索引 3
才对。我们此时可以确定的是，答案一定在 <code>[left, mid - 1]</code>
这个查找区间中。因此，我们要左移右指针，<code>right = mid - 1</code>，左移后
<code>right</code> 将指向索引 3，<code>mid</code> 将指向索引
1。</p></li>
<li><p><code>nums[mid] &lt; target</code>，和基础二分搜索思路一样，此时应当右移
<code>left</code>，<code>left = mid + 1</code>，右移后，<code>left</code>
将指向索引 2，<code>mid</code> 也将指向索引 2。</p></li>
<li><p><code>nums[mid] &lt; target</code>，继续右移 left，left
将指向索引 3，mid 也将指向索引 3。</p></li>
<li><p><code>nums[mid] == target</code>，此时就是我们想要找的答案，因为前面没有再等于
5 的啦。</p></li>
</ol>
<blockquote>
<p>Tips!</p>
<p><strong>因为是有序数组，所以相同的元素都会连在一起。</strong></p>
</blockquote>
<p>所以，和上一个问题不同的地方就是，<strong>与目标值相等时，不能直接返回索引，而是要继续收缩查找区间，也就是左移右指针</strong>，从而锁定第一个等于目标值的元素。</p>
<h2 id="参考代码-1">参考代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchFirstOne</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 如果此时 mid 是数组的第一个元素</span></span><br><span class="line">            <span class="comment">// 或者前面一个元素不等于目标值</span></span><br><span class="line">            <span class="comment">// 那么，这个元素就是答案，返回索引 mid</span></span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] != target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 答案一定出现在 mid 前面</span></span><br><span class="line">            	right = mid - <span class="number">1</span>; <span class="comment">// 缩小查找区间，左移右指针</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="答疑解惑">答疑解惑</h2>
<p><strong>为什么能够查找到第一个等于目标值的元素？</strong></p>
<p>关键点在于 <code>nums[mid] == target</code> 时的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] != target)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	    right = mid - <span class="number">1</span>; <span class="comment">// 缩小查找区间，左移右指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>nums[mid]</code> 等于目标值 <code>target</code> 时，如果
<code>mid</code> 是数组的第一个元素，或者前面一个元素不等于
<code>target</code> 话，那么 <code>nums[mid]</code>
就是我们要找的元素，返回索引 <code>mid</code>。</p>
<p>如果此时， <code>nums[mid]</code> 前面一个元素
<code>nums[mid - 1]</code> 也等于 <code>target</code>，那说明，此时的
<code>nums[mid]</code>
肯定不是我们要找的第一个等于目标值的元素，所以，我们要<strong>左移右指针来缩小查找区间</strong>，在区间
<code>[left, mid - 1]</code>
中继续查找，也就是不断向左靠拢，这样一定能找到第一个等于目标值的元素。</p>
<p>其实，我在<a
href="https://juejin.cn/post/7228571126476521531">另一篇文章</a>中，有写过该算法的另一种实现方法，更加简洁优雅，但是却不是那么容易理解，而且，无法完全解决今天的四个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchFirstOne</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 缩小查找区间，左移右指针</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然更优雅，但是理解难度比参考代码中的更难。</p>
<p>如果是你的话，你是想要更优雅但不容易理解的代码？还是没那么优雅但容易理解的代码呢？如果是我的话，我选择后者。</p>
<h1
id="查找最后一个等于目标值的元素变体2">查找最后一个等于目标值的元素（变体2）</h1>
<h2 id="具体描述-2">具体描述</h2>
<p>在一个有序数组中，存在多个大小为 <code>target</code>
值的元素，请找到最后一个等于目标值的元素（可以看作<strong>所有重复元素的右边界</strong>），如果存在，返回其索引，否则返回
-1。</p>
<h2 id="举个例子-2">举个例子🌰</h2>
<p>和查找第一个等于目标值的元素相反，<strong>找到目标值的时候，右移左指针</strong>，最终返回右指针索引即可。</p>
<p>所以，在上个问题的例子，有序数组
<code>[1, 3, 4, 5, 5, 5, 5, 5, 9]</code>，目标值 <code>target</code> 为
5，应当返回索引 7。</p>
<h2 id="参考代码-2">参考代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchLastOne</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 如果此时 mid 是数组的最后一个元素</span></span><br><span class="line">            <span class="comment">// 或者后面一个元素不等于目标值</span></span><br><span class="line">            <span class="comment">// 那么，这个元素就是答案，返回索引 mid</span></span><br><span class="line">            <span class="keyword">if</span> (mid == nums.length - <span class="number">1</span> || nums[mid + <span class="number">1</span>] != target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 答案一定出现在 mid 后面</span></span><br><span class="line">            	left = mid + <span class="number">1</span>; <span class="comment">// 缩小查找区间，右移左指针</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="答疑解惑-1">答疑解惑</h2>
<p><strong>为什么能够查找到最后一个等于目标值的元素？</strong></p>
<p>关键点在于 <code>nums[mid] == target</code> 时的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mid == nums.length - <span class="number">1</span> || nums[mid + <span class="number">1</span>] != target)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	    left = mid + <span class="number">1</span>; <span class="comment">// 缩小查找区间，右移左指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>nums[mid]</code> 等于目标值 <code>target</code> 时，如果
<code>mid</code> 是数组最后一个索引，或者后面一个元素
<code>nums[mid + 1]</code> 不等于 <code>target</code>
，那么，<code>nums[mid]</code> 就是我们要找的元素，直接返回索引
<code>mid</code>。</p>
<p>如果此时， <code>nums[mid]</code>
后面的一个元素，<code>nums[mid + 1]</code> 也等于 <code>target</code>
话，那就说明当前的 <code>nums[mid]</code>
一定不是最后一个等于给定值的元素。所以，我们要<strong>右移左指针来缩小查找区间</strong>，在区间
<code>[mid + 1, right]</code>
中继续查找，也就是不断向右靠拢，这样一定能找到最后一个等于目标值的元素。</p>
<h1
id="查找第一个大于等于目标值的元素变体3">查找第一个大于等于目标值的元素（变体3）</h1>
<h2 id="具体描述-3">具体描述</h2>
<p>在任意有序数组中，查找第一个大于等于目标值的元素。如果存在，返回目标值索引，否则返回
-1。</p>
<h2 id="举个例子-3">举个例子🌰</h2>
<p>继续使用之前的例子，有序数组
<code>[1, 3, 4, 5, 5, 5, 5, 5, 9]</code>，目标值 <code>target</code> 为
2，应该返回索引 1。</p>
<h2 id="参考代码-3">参考代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            <span class="comment">// 如果此时 mid 是数组的第一个元素</span></span><br><span class="line">            <span class="comment">// 或者前面一个元素比目标值小</span></span><br><span class="line">            <span class="comment">// 那么，这个元素就是答案，返回索引 mid</span></span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] &lt; target) </span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="答疑解惑-2">答疑解惑</h2>
<p><strong>为什么能够查找到第一个大于等于目标值的元素？</strong></p>
<p>关键点在于 <code>nums[mid] &gt;= target</code> 时的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] &lt; target)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	    right = mid - <span class="number">1</span>; <span class="comment">// 缩小查找区间，左移右指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>nums[mid]</code> 大于等于 <code>target</code> 目标值时，如果
<code>mid</code> 是数组的第一个元素，或者前面一个元素小于
<code>target</code> ，那么，<code>nums[mid]</code>
一定是我们要找的元素，返回索引 <code>mid</code>。</p>
<p>如果此时，<code>nums[mid]</code> 前面一个元素 <code>nums[mid]</code>
也大于等于我们要查找的目标值，那说明，此时的 <code>nums[mid]</code>
肯定不是我们要找的第一个大于等于目标值的元素。所以，我们要<strong>左移右指针来缩小查找区间</strong>，在区间
<code>[left, mid - 1]</code>
中继续查找，也就是不断向左靠拢，这样一定能找到第一个大于等于目标值的元素。</p>
<h1
id="查找最后一个小于等于目标值的元素变体4">查找最后一个小于等于目标值的元素（变体4）</h1>
<h2 id="具体描述-4">具体描述</h2>
<p>在任意有序数组中，查找最后一个小于等于目标值的元素。如果存在，返回目标值索引，否则返回
-1。</p>
<h2 id="举个例子-4">举个例子🌰</h2>
<p>继续使用之前的例子，有序数组
<code>[1, 3, 4, 5, 5, 5, 5, 5, 9]</code>，目标值 <code>target</code> 为
6，应该返回索引 7。</p>
<h2 id="参考代码-4">参考代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == nums.length - <span class="number">1</span> || nums[mid + <span class="number">1</span>] &gt; target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="答疑解惑-3">答疑解惑</h2>
<p><strong>为什么能够查找到最后一个小于等于目标值的元素？</strong></p>
<p>关键点在于 <code>nums[mid] &lt;= target</code> 时的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mid == nums.length - <span class="number">1</span> || nums[mid + <span class="number">1</span>] &gt; target)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	    left = mid + <span class="number">1</span>; <span class="comment">// 缩小查找区间，右移左指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>nums[mid]</code> 小于等于目标值 <code>target</code> 时，如果
<code>mid</code> 是数组最后一个索引，或者后面一个元素
<code>nums[mid + 1]</code> 不等于 <code>target</code>
，那么，<code>nums[mid]</code> 就是我们要找的元素，直接返回索引
<code>mid</code>。</p>
<p>如果此时， <code>nums[mid]</code>
后面的一个元素，<code>nums[mid + 1]</code> 也大于 <code>target</code>
话，那就说明当前的 <code>nums[mid]</code>
一定不是最后一个小于等于给定值的元素。所以，我们要<strong>右移左指针来缩小查找区间</strong>，在区间
<code>[mid + 1, right]</code>
中继续查找，也就是不断向右靠拢，这样一定能找到最后一个小于等于目标值的元素。</p>
<h1 id="如何快速定位出一个-ip-地址归属地">🔥如何快速定位出一个 IP
地址归属地？</h1>
<h2 id="情景描述-1">情景描述</h2>
<p>我们在浏览器搜索框中输入自己的 IP
地址，然后上面会显示它的归属地。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305230958829.png" alt="" style="zoom:50%;" /></p>
<p>假设，我们查询 202.102.133.13 这个 IP
地址，其归属地属于山东省东营市，那具体是如何做到的呢？</p>
<p>我们需要再地址库中搜索 202.102.133.13 这个 IP 地址，发现这个 IP
地址落在 [202.102.133.0, 202.102.133.255]
这个地址范围内，那我们就可以将这个 IP 地址范围对应的归属地
「山东省东营市」显示给用户即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[202.102.133.0, 202.102.133.255]  山东东营市 </span><br><span class="line">[202.102.135.0, 202.102.136.255]  山东烟台 </span><br><span class="line">[202.102.156.34, 202.102.157.255] 山东青岛 </span><br><span class="line">[202.102.48.0, 202.102.48.255] 江苏宿迁 </span><br><span class="line">[202.102.49.15, 202.102.51.251] 江苏泰州 </span><br><span class="line">[202.102.56.0, 202.102.56.255] 江苏连云港</span><br></pre></td></tr></table></figure>
<p>如果在庞大的 IP 地址库中逐个比对 IP
地址所在的区间，是非常耗时的。<strong>假设我们有 12 万条这样的 IP
区间与归属地的对应关系，如何快速定位出一个 IP
地址的归属地呢？</strong></p>
<h2 id="实现方案-1">实现方案</h2>
<p>如果 IP 地址区间与归属地的对应关系不经常更新，我们可以预处理这 12
万条数据，让其按照起始 IP 从小到大排序。</p>
<p>如何来排序呢？IP 地址是可以转化成 32
为的整型数。所以我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。</p>
<p>然后，<strong>这个问题就可以转化为上面的变体 4 问题
「查找最后一个小于等于目标值的元素」了</strong>。</p>
<p>当我们要查询某个 IP
归属地时，我们可以先通过二分查找，<strong>在起始地址中，找到最后一个起始
IP 小于等于这个 IP 的 IP 区间。</strong>然后，检查这个 IP 是否在这个 IP
区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。</p>
<h1 id="实战一下">实战一下</h1>
<p>如果大家能看到这里，相信一定有所收获了！下面，我们去用所学的知识去解决一些算法问题。建议先点开链接自己先做一遍，然后再看我给出的答案哦！</p>
<h2 id="二分查找力扣704"><a
href="https://leetcode.cn/problems/binary-search/">二分查找(力扣704)</a></h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305230940687.png" style="zoom:50%;" /></p>
<h3 id="参考代码-5">参考代码</h3>
<p>直接套用「查找一个数」的代码就可以啦！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-1">时间复杂度</h3>
<p><span class="math inline">\(O(logN)\)</span>，N 是数组长度。</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p><span
class="math inline">\(O(1)\)</span>，除了使用了常数个变量，没有额外的空间开销。</p>
<h2 id="在排序数组中查找元素的第一个和最后一个位置力扣34"><a
href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置(力扣34)</a></h2>
<h3 id="题目描述-1">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305241124120.png" alt="" style="zoom:50%;" /></p>
<h3 id="参考代码-6">参考代码</h3>
<p>题目要求我们找到目标值在数组中的开始位置和结束位置，所谓的目标值在数组中的开始位置就是「查找第一个等于目标值的元素」，那么同理，在数组中的结束位置就是
「查找最后一个等于目标值的元素」，这样就直接解决啦。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;searchFirstOne(nums, target), searchLastOne(nums, target)&#125;;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">searchFirstOne</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] != target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">	            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">searchLastOne</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == nums.length - <span class="number">1</span> || nums[mid + <span class="number">1</span>] != target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">	            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-2">时间复杂度</h3>
<p><span class="math inline">\(O(logN)\)</span>，N 是数组长度。</p>
<h3 id="空间复杂度-1">空间复杂度</h3>
<p><span
class="math inline">\(O(1)\)</span>，除了使用了常数个变量，没有额外的空间开销。</p>
<h2 id="在排序数组中查找数字i剑指offer53-i"><a
href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">在排序数组中查找数字I(剑指Offer53-I)</a></h2>
<h3 id="题目描述-2">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305241131621.png" style="zoom:50%;" /></p>
<h3 id="参考代码-7">参考代码</h3>
<p>这道题和上一道题整体思路是一样的，只不过最终我们要计算一下第一个和最后一个的区间内元素的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> searchFirstOne(nums, target);</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> searchLastOne(nums, target);</span><br><span class="line">    <span class="keyword">if</span> ( L == -<span class="number">1</span> || R == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R - L + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">searchFirstOne</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] != target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">	            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">searchLastOne</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == nums.length - <span class="number">1</span> || nums[mid + <span class="number">1</span>] != target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">	            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-3">时间复杂度</h3>
<p><span class="math inline">\(O(logN)\)</span>，N 是数组长度。</p>
<h3 id="空间复杂度-2">空间复杂度</h3>
<p><span
class="math inline">\(O(1)\)</span>，除了使用了常数个变量，没有额外的空间开销。</p>
<h2 id="展厅如何限制入场人数">🔥展厅如何限制入场人数？</h2>
<h3 id="题目描述-3">题目描述</h3>
<p>MWCS展共有 N 个展厅，每个展厅的报名人数记于数
nums，因疫情原因，所有展厅参展总人数上限为 cnt。若报名人数大于
cnt，则需要限制展厅入场的人数为 limit，根据输入，计算出 limit
最大值。</p>
<p>限制规则如下：</p>
<ul>
<li>如果报名总人数少于 cnt，则全部可以入场，返回 -1；</li>
<li>如果报名总人数大于 cnt，则需要设定 limit。超过 limit
的报名人数的展厅，需要将入场人数限制为 limit；其余未达到 limit
的展厅的报名人，全部可以入场。</li>
</ul>
<p>例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">nums[] = [1,4,2,5,5,1,6]; // 每个展厅的报名人数</span><br><span class="line">cnt = 13 // 总人数上限</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">2 // limit</span><br></pre></td></tr></table></figure>
<p>例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">nums[] = [1,1]; // 每个展厅的报名人数</span><br><span class="line">cnt = 1 // 总人数上限</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">0 // limit</span><br></pre></td></tr></table></figure>
<p>例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">nums[] = [1,3,4,2]; // 每个展厅的报名人数</span><br><span class="line">cnt = 195 // 总人数上限</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">-1 // limit</span><br></pre></td></tr></table></figure>
<h3 id="参考代码-8">参考代码</h3>
<p>这道题稍稍有难度了，我们看看二分查找如何在这道题里应用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxLimit</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算输入的展厅总人数 sum</span></span><br><span class="line">    <span class="comment">// 计算所有展厅中最大的入场人数 max</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">        max = Math.max(max, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果报名总人数少于 cnt，则全部可以入场，返回 -1；</span></span><br><span class="line">    <span class="keyword">if</span> (sum &lt;= cnt) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果报名总人数大于 cnt，则需要设定 limit。</span></span><br><span class="line">    <span class="comment">// 超过 limit 的报名人数的展厅，需要将入场人数限制为 limit；</span></span><br><span class="line">    <span class="comment">// 其余未达到 limit 的展厅的报名人，全部可以入场。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// limit 的取值范围一定在 [0, max] 之间，可以使用二分查找确定 limit 的值</span></span><br><span class="line">    <span class="comment">// 我们的目标是，计算 limit 之后展厅总入场人数 sum 最接近 cnt（最后一个小于等于 cnt 的值）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = max;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>); <span class="comment">// mid 就是我们要求的 limit</span></span><br><span class="line">        <span class="keyword">if</span> (calSum(nums, mid) &lt;= cnt) &#123; <span class="comment">// 传入当前的 limit，计算展厅进入总人数小于等于 cnt</span></span><br><span class="line">            <span class="comment">// 如果 limit 是最大的数，或者传入后面一个 limit 计算展厅进入总人数大于 cnt，当前 mid 一定是答案</span></span><br><span class="line">            <span class="keyword">if</span> (mid == max || calSum(nums, mid + <span class="number">1</span>) &gt; cnt) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// limit 小了，要向右靠拢，右移左指针，缩小查找区间为 [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 传入当前的 limit，计算展厅进入总人数大于 cnt </span></span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">//  limit 大了，要向左靠拢，左移右指针，缩小查找区间为 [left, mid - 1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算传入 limit 后，展厅进入的总人数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">        <span class="comment">// 取 &#123;原展厅进入人数, 限制人数&#125; 中较小的一个</span></span><br><span class="line">        sum += Math.min(n, limit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题是不是有点儿难度，主要难点有二，一是在于能否识别出要使用二分查找去解题，二是如何使用二分查找去解决。</p>
<p>我们来与「查找最后一个小于等于目标值的元素（变体 4）」做个对比。</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 36%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>变体 4</th>
<th>本题</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>目标</td>
<td>查找<strong>数组中最后一个小于等于目标值</strong>的元素</td>
<td><strong>找到最大的 <code>limit</code>
（在一个升序数组中，越靠后数越大）</strong>使得<strong>数组的累加和
<code>calSum()</code> 小于等于 <code>cnt</code>（目标值）</strong></td>
</tr>
<tr class="even">
<td>区间移动条件</td>
<td>数组中点元素值与目标值比较大小</td>
<td>当前 <code>limit</code> 下的数组累加和 <code>calSum()</code> 与
<code>cnt</code> 比较大小</td>
</tr>
<tr class="odd">
<td>初始查找范围</td>
<td><span class="math inline">\([0,\  nums.length - 1]\)</span></td>
<td><span class="math inline">\([0,\ max]\)</span>，<code>max</code>
是所有展厅中最大的入场人数，<code>limit</code> 一定不会超过这个值</td>
</tr>
</tbody>
</table>
<p>相信这样对比一下，大家应该就明白啦。另外，我再详细解释一下这段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (calSum(nums, mid) &lt;= cnt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mid == max || calSum(nums, mid + <span class="number">1</span>) &gt; cnt) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码保证了我们一定能找到最大的 <code>limit</code>
使得数组的累加和 <code>calSum()</code> 小于等于 <code>cnt</code>。</p>
<p>如果此时找到的 <code>limit</code>（就是
<code>mid</code>）满足数组累加和 <code>calSum()</code> 小于等于
<code>cnt</code>，同时呢，<code>limit</code> （就是
<code>mid</code>）又是最后一个值，或者后面一个 <code>limit</code> （就是
<code>mid</code>）使得数组累加和 <code>calSum()</code> 大于
<code>cnt</code>，那么，当前的 <code>mid</code>
就是我们要找到的值，直接返回。</p>
<p>如果此时，后面一个 <code>limit</code>（就是
<code>mid</code>）下的数组累加和 <code>calSum()</code> 也小于等于
<code>cnt</code> 的话，那么当前的 <code>limit</code>（就是
<code>mid</code>）一定不是最大的
<code>limit</code>。所以我们要右移左指针来缩小查找区间，在区间 <span
class="math inline">\([mid + 1,\  right]\)</span>
中继续查找，也就是不断向右靠拢，最终一定能找到最大的满足数组累加和
<code>calSum()</code> 小于等于 <code>cnt</code> 的 <code>limit</code>
值。</p>
<h2 id="搜索旋转排序数组力扣33"><a
href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">🔥搜索旋转排序数组（力扣33）</a></h2>
<h3 id="题目描述-4">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305242316477.png" style="zoom:50%;" /></p>
<h3 id="参考代码-9">参考代码</h3>
<p>这道题因为发生了旋转，使得数组变成了<strong>局部有序</strong>的情况。还可以二分查找吗？当然可以！</p>
<p>如果将数组从中间分开，我们会发现<strong>在查找区间 <span
class="math inline">\([left,\  right]\)</span>
中一定有一边是有序的</strong>。图示可以看到 <span
class="math inline">\([left,\  right]\)</span>
是有序的。因此，我们在每次分割完毕后，一定要查看一下 <span
class="math inline">\([left,\  mid]\)</span> 和 <span
class="math inline">\([mid + 1,\  right]\)</span>
哪边是有序的，我们要<strong>去有序的那个区间去确定区间如何移动</strong>，因为我们能够根据有序的区间判断出
<code>target</code> 是否在这个区间内。</p>
<ul>
<li>如果 <span class="math inline">\([left,\  mid]\)</span>
是有序的，并且 <code>target</code> 的大小在 <span
class="math inline">\([nums[left],\  nums[mid])\)</span>
之间，那么我们就要左移右指针，将查找区间缩小至 <span
class="math inline">\([left,\  mid - 1]\)</span>。否则要在 <span
class="math inline">\([mid + 1,\  right]\)</span> 中寻找。</li>
<li>如果 <span class="math inline">\([mid + 1,\  right]\)</span>
是有序的，且 <code>target</code> 的大小在 <span
class="math inline">\((nums[mid],\  nums[right]]\)</span>之间，我么我们就要右移左指针，将查找区间缩小至
<span class="math inline">\([mid + 1,\  right]\)</span>。否则在 <span
class="math inline">\([left,\  mid]\)</span> 中寻找。</li>
</ul>
<p>图示的情况是输入数组
<code>nums = [4, 5, 6, 7, 0, 1, 2]</code>，<code>target = 0</code>。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305242335835.png" /></p>
<ol type="1">
<li><code>nums[mid] != target</code>，<span
class="math inline">\([left,\  mid]\)</span>
是有序的，<code>target</code> 不在 <span
class="math inline">\([nums[left],\  nums[mid])\)</span>
区间，右移左指针，将查找区间缩小至 <span class="math inline">\([mid +
1,\  right]\)</span>。<code>left</code> 将指向索引 4，<code>mid</code>
将指向索引 1。</li>
<li>nums[mid] != target，<span
class="math inline">\([left,\  mid]\)</span>
是有序的，<code>target</code> 在 <span
class="math inline">\([nums[left],\  nums[mid])\)</span>
区间，左移右指针，将查找区间缩小至 <span
class="math inline">\([left,\  mid - 1]\)</span>。 right 将指向索引
4，mid 将指向索引 4。</li>
<li>nums[mid] == target，返回索引 mid。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 判断边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123; <span class="comment">// 左半边是有序的，[left, mid] 有序</span></span><br><span class="line">            <span class="comment">// 如果 target 在 [left, mid) 之间，左移右指针，缩小查找区间 </span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则右移左指针，缩小查找区间</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右半边是有序的，[mid + 1, right] 有序</span></span><br><span class="line">            <span class="comment">// 如果 target 在 (mid, right] 之间，右移左指针，缩小查找区间</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则左移右指针，缩小查找区间 </span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="框架">框架</h1>
<p>根据前面所讲的内容，我们提炼出如下的二分查找框架。建议再次回看一下基础用法和四种变体的代码，相信你一定会惊呼，原来都是一个套路！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>; <span class="comment">// 查找区间是闭区间 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 可以遍历 nums 数组中所有元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 有时可以和其他条件合并</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (...直接返回 mid 需要达成的条件...)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ...根据题目，移动查找区间...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>二分查找是一种针对有序数组的高效查找算法，时间复杂度为 <span
class="math inline">\(O(logn)\)</span>。</p>
<p>它的核心思想非常简单，和分治思想类似。每次都取<strong>查找区间</strong>的中间元素与目标值对比，然后收缩（折半）查找区间，直到找到要查找的元素，或者区间缩小至
0。</p>
<p>二分查找虽然看上去简单，但是代码很容易出错，尤其是在变体问题上，因此在写代码时务必考虑以下细节：<strong>循环退出条件</strong>、<strong>查找终止条件</strong>、<strong>区间左右边界更新方法</strong>、<strong>返回值的选择</strong>。</p>
<p>二分查找的性能十分优秀，但是应用场景比较有限。<strong>其底层依赖数组，并且数组中的数据必须是有序的</strong>。二分查找十分适合处理静态数据，也就是数据集合没有频繁的数据插入、删除操作。</p>
<p><strong>大多数二分查找能解决的问题，更倾向于使用散列表或者二叉查找树去解决。</strong>即使二分查找在内存使用上更节省，但是内存资源特别紧缺的情况并不多见。那这意味着二分查找没什么用处了吗？当然不是。</p>
<p>基础用法「查找一个数」的二分查找确实不怎么会被使用，<strong>二分查找更适合用在「近似」查找问题</strong>，在这类问题上，二分查找的优势十分明显，比如那
4 个变体问题，用散列表、二叉查找树就比较难实现了。</p>
<p>十分建议朋友们学习完毕后<strong>手动实现一遍所有代码</strong>，这样才会真正地消化吸收。</p>
<p>如果以上的内容对你有帮助，希望点赞收藏加关注，你的鼓励是我更新的动力，希望我们可以一起变得更强！</p>
<h1 id="更新日志">更新日志</h1>
<table>
<thead>
<tr class="header">
<th>更新日期</th>
<th>更新内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2023.5.27</td>
<td>提炼了一套二分查找代码框架</td>
</tr>
</tbody>
</table>
<h1 id="参考资料">参考资料</h1>
<ol type="1">
<li>数据结构与算法之美</li>
<li>算法（第四版）</li>
<li>算法图解</li>
<li>牛客网</li>
<li>力扣网</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法框架</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法框架</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 面试必知必会 —— 全面解读 Java IO(基础篇)</title>
    <url>/article/4aa40f26.html</url>
    <content><![CDATA[<p>Java IO 一直以来是大厂面试题中的高频考点，本文将从 Java IO
基础使用说起，以案例 +
源码的方式讲解文件、字节流、字符流、缓冲流、打印流、随机访问流等基础内容，再深入到
Java IO 模型与设计模式，从而构建起对 Java IO 的全面认知。</p>
<p>文章不仅适合完全不了解 Java IO
的新同学，也适合具备一定知识储备的老同学。文中的所有案例代码强烈推荐手写复现一遍，以更好地掌握
Java IO 编程基础。</p>
<p>文章的结尾处给出了更新日志，每次新更新的内容都会写明，便于同学们快速了解更新的内容是否是自己所需要的知识点。</p>
<p>我相信，友好的讨论交流会让彼此快速进步！文章难免有疏漏之处，十分欢迎大家在评论区中批评指正。</p>
<span id="more"></span>
<h2 id="文件">文件</h2>
<p>文件在程序中是以流的形式来操作的。类关系如下：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305122322419.png" /></p>
<h3 id="创建文件">创建文件</h3>
<h4 id="常用构造方法">常用构造方法</h4>
<table>
<thead>
<tr class="header">
<th>常用构造方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>File(String pathname)</td>
<td>根据路径名构建</td>
</tr>
<tr class="even">
<td>File(File parent, String child)</td>
<td>根据父目录文件 + 子路径构建</td>
</tr>
<tr class="odd">
<td>File(String parent, String child)</td>
<td>根据父目录路径 + 子路径构建</td>
</tr>
</tbody>
</table>
<p>要想真正地在磁盘中创建文件，需要执行 <code>createNewFile()</code>
方法。</p>
<h4 id="使用案例">使用案例</h4>
<blockquote>
<p>Tips</p>
<ol type="1">
<li>所有 <code>java.io</code>
中的类的<strong>相对路径</strong>默认都是从<strong>用户工作目录</strong>开始的，使用
<code>System.getProperty("user.dir")</code>
可以获取你的用户工作目录。</li>
<li>在 Windows 系统中的分隔符为 "<code>\\</code>"，在 Linux
系统中分隔符为
"<code>/</code>"，为了保证系统的可移植性，可以通过常量字符串
<code>java.io.File.separator</code> 获取(参见案例中的使用)。</li>
</ol>
</blockquote>
<ol type="1">
<li>使用 <code>File(String pathname)</code> 创建文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFile</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 更换成你想要存放的文件路径，默认情况为用户工作目录，可以通过 System.getProperty(&quot;user.dir&quot;) 显示获取</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;用户工作目录：&quot;</span> + userDir);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前操作系统的文件分隔符为：&quot;</span> + File.separator);</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;createFile.txt&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> userDir + File.separator + fileName; <span class="comment">// 组装路径</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path); <span class="comment">// 此时只是程序中的一个对象</span></span><br><span class="line">    <span class="comment">// File file = new File(fileName); // 默认会创建到用户工作目录中，和上一面的语句创建的文件路径一致。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile(); <span class="comment">// 执行该方法才会真正地在磁盘中创建文件</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用 <code>File(File parent, String child)</code> 创建文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFile2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 更换成你想要存放的文件路径</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;createFile2.txt&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, fileName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>使用 <code>File(String parent, String child)</code> 创建文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFile3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 更换成你想要存放的文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">parentFile</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;createFile3.txt&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, fileName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取文件信息">获取文件信息</h3>
<h4 id="常用方法">常用方法</h4>
<table>
<thead>
<tr class="header">
<th>返回值</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>String</td>
<td>getName()</td>
<td>获取文件名</td>
</tr>
<tr class="even">
<td>String</td>
<td>getAbsolutePath()</td>
<td>获取文件绝对路径</td>
</tr>
<tr class="odd">
<td>String</td>
<td>getParent()</td>
<td>获取文件父级目录</td>
</tr>
<tr class="even">
<td>long</td>
<td>length()</td>
<td>返回文件大小(字节)</td>
</tr>
<tr class="odd">
<td>boolean</td>
<td>exists()</td>
<td>判断文件是否存在</td>
</tr>
<tr class="even">
<td>boolean</td>
<td>isFile()</td>
<td>判断是否是一个文件</td>
</tr>
<tr class="odd">
<td>boolean</td>
<td>isDirectory()</td>
<td>判断是否是一个目录</td>
</tr>
</tbody>
</table>
<h4 id="使用案例-1">使用案例</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFileInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/sunnywinter/projects/interviewcode/testFile.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;文件名：&quot;</span> + file.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件绝对路径：&quot;</span> + file.getAbsolutePath());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件父级目录：&quot;</span> + file.getParent());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件大小(字节)：&quot;</span> + file.length());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件是否存在：&quot;</span> + file.exists());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否是一个文件：&quot;</span> + file.isFile());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否是一个目录：&quot;</span> + file.isDirectory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="目录操作与文件删除">目录操作与文件删除</h3>
<h4 id="使用方法">使用方法</h4>
<table>
<thead>
<tr class="header">
<th>返回值</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>boolean</td>
<td>mkdir()</td>
<td>创建一级目录</td>
</tr>
<tr class="even">
<td>boolean</td>
<td>mkdirs()</td>
<td>创建多级目录</td>
</tr>
<tr class="odd">
<td>boolean</td>
<td>delete()</td>
<td>删除文件或目录</td>
</tr>
</tbody>
</table>
<h4 id="使用案例-2">使用案例</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="string">&quot;/Users/sunnywinter/projects/interviewcode/&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;testFile.txt&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">directoryName</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">mulDirectoryName</span> <span class="operator">=</span> <span class="string">&quot;b/c/d&quot;</span>;</span><br><span class="line">    <span class="comment">// 删除文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentPath, fileName);</span><br><span class="line">    file.delete();</span><br><span class="line">    <span class="comment">// 创建一级目录</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">directory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentPath, directoryName);</span><br><span class="line">    directory.mkdir();</span><br><span class="line">    <span class="comment">// 创建多级目录</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">mulDirectory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentPath, mulDirectoryName);</span><br><span class="line">    mulDirectory.mkdirs();</span><br><span class="line">    <span class="comment">// 删除目录</span></span><br><span class="line">    directory.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="io-流概述">IO 流概述</h2>
<p>IO，Input/Output，即输入/输出。判断输入输出以计算机内存为中心，如果从内存到外部存储就是输出，从外部存储到内存就是输入。数据传输过程类似于水流，因此称为
IO 流。</p>
<blockquote>
<p>注意，流的提供者不仅可以是内存、文件、也可以是网络连接。</p>
</blockquote>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305122155153.png"
alt="输入输出流判断" />
<figcaption aria-hidden="true">输入输出流判断</figcaption>
</figure>
<p>在 Java 中，根据操作数据单位的不同，IO
流分为字节流和字符流；根据数据流的流向不同，分为输入流和输出流；根据流的角色不同，分为节点流和处理流。</p>
<p>Java IO 流共涉及 40 多个类，但都是从表中的 4
个抽象基类派生而来，派生的子类名称都是以其父类名作为子类名的后缀。</p>
<table>
<thead>
<tr class="header">
<th>（抽象基类）</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr class="even">
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody>
</table>
<p>列举一些常用的类。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305122153811.png"
alt="IO 流常用类" />
<figcaption aria-hidden="true">IO 流常用类</figcaption>
</figure>
<h2 id="字节流">字节流</h2>
<p>首先，我们先学习如何将数据写入到文件中。</p>
<h3 id="outputstream字节输出流">OutputStream(字节输出流)</h3>
<p>OutputStream
用于将内存数据(字节信息)写入到文件中，<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p>
<h4 id="常用方法-1">常用方法</h4>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 33%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>返回值</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>void</td>
<td>write(int b)</td>
<td>将特定字节写入输出流。</td>
</tr>
<tr class="even">
<td>void</td>
<td>write(byte b[])</td>
<td>将数组 <code>b</code> 写入到输出流，等价于
<code>write(b, 0, b.length)</code> 。</td>
</tr>
<tr class="odd">
<td>void</td>
<td>write(byte[] b, int off, int len)</td>
<td>在 <code>write(byte b[])</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</td>
</tr>
<tr class="even">
<td>void</td>
<td>flush()</td>
<td>刷新此输出流并强制写出所有缓冲的输出字节。</td>
</tr>
<tr class="odd">
<td>void</td>
<td>close()</td>
<td>关闭输出流释放相关的系统资源。</td>
</tr>
</tbody>
</table>
<h4 id="fileoutputstream">FileOutputStream</h4>
<p><code>FileOutputStream</code>
是最常用的字节输出流子类，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p>
<p>类图关系如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305132234784.png" style="zoom:50%;" /></p>
<blockquote>
<p><strong>Tips</strong></p>
<p><code>java.io.Closeable</code> 接口扩展了 java.lang.AutoCloseable
接口。因此，对任何 Closeable 进行操作时，都可以使用 try-with-resource
语句(声明了一个或多个资源的 try
语句，可以自动关闭流，具体使用方法参见使用案例)。
为什么要有两个接口呢？因为 Closeable 接口的 close 方法只抛出了
IOException，而 AutoCloseable.close 方法可以抛出任何异常。</p>
</blockquote>
<p><strong>常用构造函数</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305131514442.png" alt="FileOutputStream 构造函数" style="zoom:50%;" /></p>
<p><code>append</code> 为 true 时，表明追加写入。</p>
<h5 id="使用案例-3">使用案例</h5>
<p><strong>需求 1：向 mrpersimmon.txt 文件中写入
Hi,Mrpersimmon!</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileOutputStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// FileOutputStream(String name, boolean append) 追加写入</span></span><br><span class="line">    <span class="comment">// FileOutputStream(String name) 覆盖写入</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mrpersimmon.txt&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hi,Mrpersimmon!&quot;</span>;</span><br><span class="line">        <span class="comment">// write(byte b[]) : 将字节数组 b 写入到输出流，等价于 write(b, 0, b.length)</span></span><br><span class="line">        bos.write(str.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// str.getBytes() 字符串 -&gt; 字节数组</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips</strong></p>
<ol type="1">
<li><code>FileOutputStream</code> 在使用中要和
<code>BufferedOutputStream</code> 一起使用，性能更好。</li>
<li>try(...OutputStream) 可以自动关闭输出流，无需 try-finally
手动关闭。</li>
</ol>
</blockquote>
<p><strong>运行结果：</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305131525231.png" /></p>
<h4 id="dataoutputstream">DataOutputStream</h4>
<p><strong><code>DataOutputStream</code></strong>
以二进制格式写入所有的基本 Java 类型数据，不能单独使用，必须结合
<code>FileOutputStream</code>，构造函数源码如下：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305131529547.png"
alt="DataOutputStream 构造函数" />
<figcaption aria-hidden="true">DataOutputStream 构造函数</figcaption>
</figure>
<p>类图关系如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305132235515.png" style="zoom:50%;" /></p>
<h5 id="使用案例-4">使用案例</h5>
<p>需求：向 mrpersimmon2.txt 写入 Hi,Mrpersimmon!</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDataOutputStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mrpersimmon2.txt&quot;</span>))) &#123;</span><br><span class="line">        <span class="comment">// 输出任意输入类型</span></span><br><span class="line">        dos.writeUTF(<span class="string">&quot;Hi,Mrpersimmon!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305131536818.png" /></p>
<hr />
<h4 id="objectoutputstream">ObjectOutputStream</h4>
<p><code>ObjectOutputStream</code>
用于将对象写入到输出流(序列化)。与之相对反地，<code>ObjectInputStream</code>
用于从输入流中读取 Java 对象(反序列化)。</p>
<p>类图关系如下：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305132236103.png" /></p>
<h5 id="序列化与反序列化">序列化与反序列化</h5>
<p><strong>什么是序列化和反序列化？</strong>序列化就是在保存数据时，保存数据的值和数据类型；反序列化就是在恢复数据时，恢复数据的值和数据类型。</p>
<p><strong>如何让类支持序列化机制呢？</strong>必须让类实现
<code>Serializable</code> 接口(一个标记接口，没有方法)或者
<code>Externalizable</code>
接口(有方法需要实现)。如果类中有属性不想被序列化，需要使用
<code>transient</code> 修饰。</p>
<p><strong>注意事项</strong></p>
<ol type="1">
<li>读写顺序要一致；</li>
<li>要求序列化和反序列化的对象，需要实现 Serializable 接口</li>
<li>序列化的类中建议添加 serialVersionUID 以太高版本的兼容性</li>
<li>序列化对象时，默认将所有属性进行了序列化，但除了 static 或 transient
修饰的成员</li>
<li>序列化对象时，要求里面属性的类型也需要实现序列化接口</li>
<li>序列化具备可继承性，即某个类实现了序列化，那么它的所有子类也默认实现了序列化。</li>
<li>基本类型对应的包装类都实现了序列化。</li>
</ol>
<h5 id="使用案例-5"><strong>使用案例</strong></h5>
<p><strong>需求：创建一个支持序列化的 Blog 类，向 mrpersimmon3.txt
写入一个 Blog 对象。</strong></p>
<p>代码：</p>
<p>Blog 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">4970674810941727545L</span>;</span><br><span class="line">    String name;</span><br><span class="line">    String url;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Blog</span><span class="params">(String name, String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Blog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, url=&#x27;&quot;</span> + url + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectOutputStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mrpersimmon3.txt&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blog</span>(<span class="string">&quot;mrpersimmon&quot;</span>, <span class="string">&quot;https://www.mrpersimmon.top&quot;</span>);</span><br><span class="line">        oos.writeObject(blog);</span><br><span class="line">        System.out.println(<span class="string">&quot;数据写入完成(序列化)&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305131550468.png" /></p>
<p>下面我们来学习如何从文件中读取数据信息。</p>
<hr />
<h3 id="inputstream字节输入流">InputStream(字节输入流)</h3>
<p><code>InputStream</code>
用于从文件读取数据(字节信息)到内存中，<code>java.io.InputStream</code>
抽象类是所有字节输入流的父类。</p>
<h4 id="常用方法-2">常用方法</h4>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 36%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="header">
<th>返回值</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>JDK 8 ↓</td>
<td>JDK 8 ↓</td>
<td>JDK 8 ↓</td>
</tr>
<tr class="even">
<td>int</td>
<td>read()</td>
<td>返回输入流中下一个字节的数据。返回的值介于 0 到 255
之间。如果未读取任何字节，则代码返回 <code>-1</code>
，表示文件结束。</td>
</tr>
<tr class="odd">
<td>int</td>
<td>read(byte b[ ])</td>
<td>从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组
<code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回
<code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于
<code>b.length</code> ，返回读取的字节数。这个方法等价于
<code>read(b, 0, b.length)</code>。</td>
</tr>
<tr class="even">
<td>int</td>
<td>read(byte b[], int off, int len)</td>
<td>在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</td>
</tr>
<tr class="odd">
<td>long</td>
<td>skip(long n)</td>
<td>忽略输入流中的 <code>n</code> 个字节 ，返回实际忽略的字节数。</td>
</tr>
<tr class="even">
<td>int</td>
<td>available()</td>
<td>返回输入流中可以读取的字节数。</td>
</tr>
<tr class="odd">
<td>void</td>
<td>close()</td>
<td>关闭输入流释放相关的系统资源。</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>JDK 9 ↓</td>
<td>JDK 9 ↓</td>
<td>JDK 9 ↓</td>
</tr>
<tr class="even">
<td>byte[]</td>
<td>readAllBytes()</td>
<td>读取输入流中的所有字节，返回字节数组。</td>
</tr>
<tr class="odd">
<td>byte[]</td>
<td>readNBytes(byte[] b, int off, int len)</td>
<td>阻塞直到读取 <code>len</code> 个字节。</td>
</tr>
<tr class="even">
<td>long</td>
<td>transferTo(OutputStream out)</td>
<td>将所有字节从一个输入流传递到一个输出流。</td>
</tr>
</tbody>
</table>
<h4 id="fileinputstream">FileInputStream</h4>
<p><code>FileInputStream</code>
是一个比较常用的字节输入流子类，可<strong>直接指定文件路径</strong>，可以<strong>直接读取单字节数据</strong>，也可以<strong>读取至字节数组中</strong>。</p>
<p>类图关系如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305132236058.png" style="zoom:50%;" /></p>
<h5 id="使用案例-6">使用案例</h5>
<p><strong>需求：读取 mrpersimmon.txt
文件，并将文件内容显示到控制台中。</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305131558200.png" /></p>
<p><strong>方法 1：使用 read() 单个字节读取，效率较低。</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// try() 会自动关闭输入流，FileInputStream 与 BufferedInputStream 配合使用</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mrpersimmon.txt&quot;</span>))) &#123;</span><br><span class="line">        <span class="comment">// int available() 返回输入流中可以读取的字节数。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件中可读取的字节数量：&quot;</span> + bufferedInputStream.available());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// long skip(long n) 忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">skipCounts</span> <span class="operator">=</span> bufferedInputStream.skip(<span class="number">3</span>); <span class="comment">// 忽略 3 个字节</span></span><br><span class="line">        System.out.println(<span class="string">&quot;忽略的字节数量：&quot;</span> + skipCounts);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read() 返回输入流中下一个字节的数据。</span></span><br><span class="line">        System.out.print(<span class="string">&quot;从文件中读取的字节内容：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> content;</span><br><span class="line">        <span class="comment">// 返回值为 -1 时，表示读取完毕</span></span><br><span class="line">        <span class="keyword">while</span> ((content = bufferedInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) content); <span class="comment">// 将读出的 int 类型数据强转成 char 类型</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips</strong></p>
<ol type="1">
<li>FileInputStream 在使用中要和 BufferedInputStream
一起使用，性能更好。</li>
<li>try(...InputStream) 可以自动关闭输入流，无需 try-finally
手动关闭。</li>
</ol>
</blockquote>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件中可读取的字节数量：15</span><br><span class="line">忽略的字节数量：3</span><br><span class="line">从文件中读取的字节内容：Mrpersimmon!</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>方法 2：使用 read(byte[] b) 读取文件，提高效率。</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputStream2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// try() 会自动关闭输入流，FileInputStream 与 BufferedInputStream 配合使用</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mrpersimmon.txt&quot;</span>))) &#123;</span><br><span class="line">        <span class="comment">// int available() 返回输入流中可以读取的字节数。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bufSize</span> <span class="operator">=</span> bufferedInputStream.available();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件中可读取的字节数量：&quot;</span> + bufSize);</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>]; <span class="comment">// 一次读取 8 字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// long skip(long n) 忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">skipCounts</span> <span class="operator">=</span> bufferedInputStream.skip(<span class="number">3</span>); <span class="comment">// 忽略 3 个字节</span></span><br><span class="line">        System.out.println(<span class="string">&quot;忽略的字节数量：&quot;</span> + skipCounts);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read(byte b[]) 从输入流中读取一些字节存储到数组 b 中。</span></span><br><span class="line">        <span class="comment">// 如果数组 b 的长度为零，则不读取。</span></span><br><span class="line">        <span class="comment">// 如果没有可用字节读取，返回 -1。</span></span><br><span class="line">        <span class="comment">// 如果有可用字节读取，则最多读取的字节数最多等于 b.length，返回读取的字节数。</span></span><br><span class="line">        <span class="comment">// 这个方法等价于 read(b, 0, b.length)。</span></span><br><span class="line">        System.out.print(<span class="string">&quot;从文件中读取的字节内容：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> readLen;</span><br><span class="line">        <span class="comment">// 返回值为 -1 时，表示读取完毕</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen = bufferedInputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen)); <span class="comment">// 将字符数组 buf 转换成字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件中可读取的字节数量：15</span><br><span class="line">忽略的字节数量：3</span><br><span class="line">从文件中读取的字节内容：Mrpersimmon!</span><br></pre></td></tr></table></figure>
<h4 id="datainputstream">DataInputStream</h4>
<p><code>DataInputStream</code> 以二进制格式读取所有的基本 Java
类型数据，不能单独使用，必须结合 <code>InputStream</code>
的一个实现类使用，构造函数源码如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305131437368.png" alt="DataInputStream 源码中的构造函数" style="zoom:50%;" /></p>
<p>类图关系如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305132237922.png" style="zoom:50%;" /></p>
<h5 id="使用案例-7">使用案例</h5>
<p><strong>需求：读取 mrpersimmon2.txt
文件，并将文件内容显示到控制台中。</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDataInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 必须将一个 InputStream 的实现类作为构造参数才能使用</span></span><br><span class="line">    <span class="keyword">try</span>(<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mrpersimmon2.txt&quot;</span>))) &#123;</span><br><span class="line">        <span class="comment">// 可以读取任意具体的类型数据</span></span><br><span class="line">        System.out.println(dis.readUTF()); <span class="comment">// 读取已使用 modified UTF-8 格式编码的字符串。</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hi,Mrpersimmon!</span><br></pre></td></tr></table></figure>
<h4 id="objectinputstream">ObjectInputStream</h4>
<p><code>ObjectInputStream</code> 用于从输入流中读取 Java
对象（反序列化）。</p>
<p>类图关系如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305132237936.png" style="zoom:50%;" /></p>
<h5 id="使用案例-8">使用案例</h5>
<p><strong>需求：读取 mrpersimmon3.txt 中的 Blog 对象。</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectInputStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mrpersimmon3.txt&quot;</span>))) &#123;</span><br><span class="line">        System.out.println(ois.readObject());</span><br><span class="line">        System.out.println(<span class="string">&quot;数据读取完毕(反序列化完成)&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Blog&#123;name=&#x27;mrpersimmon&#x27;, url=&#x27;https://www.mrpersimmon.top&#x27;&#125;</span><br><span class="line">数据读取完毕(反序列化完成)</span><br></pre></td></tr></table></figure>
<h3 id="综合案例">综合案例</h3>
<h4 id="需求">需求</h4>
<p>完成图片的拷贝。</p>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCopyPic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcPicPath</span> <span class="operator">=</span> <span class="string">&quot;data.png&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">destPicPath</span> <span class="operator">=</span> <span class="string">&quot;data2.png&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcPicPath));</span><br><span class="line">         <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destPicPath))) &#123;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((readLen = bis.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// bis 输入流从源图片文件读取数据后，写入到 bos 输出流的目标文件地址</span></span><br><span class="line">            bos.write(buf, <span class="number">0</span>, readLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符流">字符流</h2>
<h3 id="字符流与字节流的对比">字符流与字节流的对比</h3>
<p><strong>为什么 I/O
流操作要分为字节流操作和字符流操作呢？</strong></p>
<ol type="1">
<li>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。因此，字节流是必要的。而字符流是由
Java 虚拟机将字节转换得到的，相比较于字节流更加耗时。</li>
<li>字节流在不知道编码类型的情况下很容易出现乱码问题，因此我们需要字符流来读取文本文件。</li>
</ol>
<p><strong>何时使用字节流，何时使用字符流？</strong></p>
<p>如果是音频文件、图片等媒体文件使用用字节流会有更好的性能优势；</p>
<p>如果涉及到字符的话(如，文本文件等)使用字符流比较好。</p>
<p><strong>常用字符编码所占字节数？</strong></p>
<p>字符流默认采用的是 <code>Unicode</code>
编码，我们可以通过构造方法自定义编码。</p>
<p><code>utf8</code>，英文占 1 字节，中文占 3 字节；</p>
<p><code>unicode</code>：任何字符都占 2 个字节；</p>
<p><code>gbk</code>：英文占 1 字节，中文占 2 字节。</p>
<h3 id="writer字符输出流">Writer(字符输出流)</h3>
<p><code>Writer</code>用于将内存数据(字符信息)写入到文件，<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p>
<h4 id="常用方法-3">常用方法</h4>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 35%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="header">
<th>返回值</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>void</td>
<td>write(int c)</td>
<td>写入单个字符。</td>
</tr>
<tr class="even">
<td>void</td>
<td>write(char[] cbuf)</td>
<td>写入字符数组
<code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</td>
</tr>
<tr class="odd">
<td>void</td>
<td>write(char[] cbuf, int off, int len)</td>
<td>在<code>write(char[] cbuf)</code> 方法的基础上增加了
<code>off</code> 参数（偏移量）和 <code>len</code>
参数（要读取的最大字符数）。</td>
</tr>
<tr class="even">
<td>void</td>
<td>write(String str)</td>
<td>写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</td>
</tr>
<tr class="odd">
<td>void</td>
<td>write(String str, int off, int len)</td>
<td>在<code>write(String str)</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</td>
</tr>
<tr class="even">
<td>Writer</td>
<td>append(CharSequence csq)</td>
<td>将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该
<code>Writer</code> 对象。</td>
</tr>
<tr class="odd">
<td>Writer</td>
<td>append(char c)</td>
<td>将指定的字符附加到指定的 <code>Writer</code> 对象并返回该
<code>Writer</code> 对象.</td>
</tr>
<tr class="even">
<td>void</td>
<td>flush()</td>
<td>刷新此输出流并强制写出所有缓冲的输出字符。</td>
</tr>
<tr class="odd">
<td>void</td>
<td>close()</td>
<td>关闭输出流释放相关的系统资源。</td>
</tr>
</tbody>
</table>
<h4 id="filewriter">FileWriter</h4>
<p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类
<code>FileWriter</code>
是基于该基础上的封装，可以直接将字符写入到文件。</p>
<p>类图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305132234849.png" style="zoom:50%;" /></p>
<h5 id="使用案例-9">使用案例</h5>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;mrpersimmon-1.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath))) &#123;</span><br><span class="line">        bw.write(<span class="string">&quot;Hi,Mrpersimmon!&quot;</span>);</span><br><span class="line">        bw.write(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 添加换行符</span></span><br><span class="line">        bw.write(<span class="string">&quot;欢迎你来到柿子博客&quot;</span>.toCharArray(), <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// toCharArray 可以将字符串转换成字符数组</span></span><br><span class="line">        bw.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        bw.write(<span class="string">&quot;欢迎你来到柿子博客&quot;</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips</strong></p>
<ol type="1">
<li>FileWriter 要和 BufferedWriter 一起使用，性能更好；</li>
<li>一定要关闭输出流或者 flush ，否则无法写入到文件中。</li>
</ol>
</blockquote>
<p><strong>运行结果</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305141552401.png" style="zoom:50%;" /></p>
<h3 id="reader字符输入流">Reader(字符输入流)</h3>
<p><code>Reader</code>用于从文件读取数据(字符信息)到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p>
<h4 id="常用方法-4">常用方法</h4>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 34%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="header">
<th>返回值</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>int</td>
<td>read()</td>
<td>从输入流读取一个字符。</td>
</tr>
<tr class="even">
<td>int</td>
<td>read(char[] cbuf)</td>
<td>从输入流中读取一些字符，并将它们存储到字符数组
<code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code>
。</td>
</tr>
<tr class="odd">
<td>int</td>
<td>read(char[] cbuf, int off, int len)</td>
<td>在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</td>
</tr>
<tr class="even">
<td>long</td>
<td>skip(long n)</td>
<td>忽略输入流中的 n 个字符，返回实际忽略的字符数。</td>
</tr>
<tr class="odd">
<td>void</td>
<td>close()</td>
<td>关闭输入流并释放相关的系统资源。</td>
</tr>
</tbody>
</table>
<h4 id="filereader">FileReader</h4>
<p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类
<code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305141606118.png" style="zoom:50%;" /></p>
<h5 id="使用案例-10">使用案例</h5>
<p><strong>需求</strong>：读取 mrpersimmon-1.txt 中的信息</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;mrpersimmon-1.txt&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((readLen = br.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(cbuf, <span class="number">0</span>, readLen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hi,Mrpersimmon!</span><br><span class="line">欢迎你</span><br><span class="line">来到柿子博客</span><br></pre></td></tr></table></figure>
<h2 id="字节字符缓冲流">字节/字符缓冲流</h2>
<p>IO
操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节/字符，从而避免频繁的
IO 操作，提高流的传输效率。</p>
<p>字节缓冲流这里采用了<strong>装饰器模式</strong>来增强
<code>InputStream</code>
和<code>OutputStream</code>子类对象的功能。字符缓冲流同理。</p>
<p>常见的使用方式已在上面的使用案例中给出，使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;mrpersimmon-1.txt&quot;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="字节流和字节缓冲流性能对比">字节流和字节缓冲流性能对比</h3>
<p>字节流和字节缓冲流的性能差别主要体现在调用 <code>write(int b)</code>
和 <code>read()</code>
这两种一次只写入/读取一个节点的方式时。由于<strong>字节缓冲流内部有缓冲区(字节数组)</strong>，因此，<strong>字节缓冲流会先将读取到的字节存放在缓存区</strong>，大幅减少
IO 次数，提高读取效率。</p>
<h4 id="测试对比-1单字节处理">测试对比 1（单字节处理）</h4>
<p>分别使用字节流和字节缓冲流的方式复制一个 207 MB 的 PDF
文件，查看耗时对比。</p>
<h5 id="代码-1">代码</h5>
<p><strong>1. 使用字节流复制 PDF 文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileByStream</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;使用字节流复制 PDF 文件测试开始&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;/Users/sunnywinter/Downloads/深入剖析Kubernetes.pdf&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;/Users/sunnywinter/Downloads/深入剖析Kubernetes-stream.pdf&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcPath);</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destPath)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">content</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((content = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;使用字节流复制 PDF 文件总耗时 &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 使用缓冲字节流复制 PDF 文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileByBufferStream</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲字节流复制 PDF 文件测试开始&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="comment">// 文件大小 207 MB</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;/Users/sunnywinter/Downloads/深入剖析Kubernetes.pdf&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;/Users/sunnywinter/Downloads/深入剖析Kubernetes-buffer-stream.pdf&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcPath));</span><br><span class="line">         <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destPath))) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">content</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((content = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲字节流复制 PDF 文件总耗时 &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="结果对比">结果对比</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用字节流复制 PDF 文件总耗时 1052141 毫秒</span><br><span class="line"></span><br><span class="line">使用缓冲字节流复制 PDF 文件总耗时 6521 毫秒</span><br></pre></td></tr></table></figure>
<p>可以看到，两者耗时差别绝大，相较于字节流，使用缓冲字节流节省约 161
倍的耗时。</p>
<h4 id="测试内容-2字节数组处理">测试内容 2（字节数组处理）</h4>
<p>分别使用字节流+字节数组、字节缓冲流+字节数组的方式复制一个 207 MB 的
PDF 文件，查看耗时对比。</p>
<h5 id="代码-2">代码</h5>
<p><strong>1. 使用字节流 + 字节数组复制 PDF 文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileByByteArrStream</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;使用字节流+字节数组复制 PDF 文件测试开始&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="comment">// 文件大小 207 MB</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;/Users/sunnywinter/Downloads/深入剖析Kubernetes.pdf&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;/Users/sunnywinter/Downloads/深入剖析Kubernetes-arr-stream.pdf&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcPath);</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destPath)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((readLen = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(b, <span class="number">0</span>, readLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;使用字节流 + 字节数组复制 PDF 文件总耗时 &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 使用缓冲字节流 + 字节数组复制 PDF 文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileByByteArrBufferStream</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲字节流+字节数组复制 PDF 文件测试开始&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="comment">// 文件大小 207 MB</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;/Users/sunnywinter/Downloads/深入剖析Kubernetes.pdf&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;/Users/sunnywinter/Downloads/深入剖析Kubernetes-arr-buf-stream.pdf&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcPath));</span><br><span class="line">         <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destPath))) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((readLen = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, readLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲字节流 + 字节数组复制 PDF 文件总耗时&quot;</span> + (endTime - startTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="结果对比-1">结果对比</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用字节流 + 字节数组复制 PDF 文件总耗时 478 毫秒</span><br><span class="line"></span><br><span class="line">使用缓冲字节流 + 字节数组复制 PDF 文件总耗时 391 毫秒</span><br></pre></td></tr></table></figure>
<p>可以看到，两者差距不是特别大，但是缓冲字节流仍具有优势。</p>
<h4 id="结论">结论</h4>
<p>在日常使用时，应当使用缓冲流，以获取更好的性能优势。</p>
<p>字符缓冲流也是同理，限于篇幅，不再提供测试案例，感兴趣的同学可以自行测试。</p>
<h3 id="源码分析">源码分析</h3>
<h4 id="bufferedinputstream">BufferedInputStream</h4>
<p><code>BufferedInputStream</code>
内部维护了一个缓冲区，这个缓冲区是一个字节数组。下面是源码中的一部分内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">    <span class="comment">// 缓冲区默认大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEFAULT_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line">    <span class="comment">// 内部缓冲区字节数组</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">byte</span> buf[];</span><br><span class="line">    <span class="comment">// 构造函数，使用默认的缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数，使用自定义的缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bufferedoutputstream">BufferedOutputStream</h4>
<p>下面是源码中的一部分内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedOutputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterOutputStream</span> &#123;</span><br><span class="line">    <span class="comment">// 内部缓冲区字节数组</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">byte</span> buf[];</span><br><span class="line">    <span class="comment">// 构造函数，默认缓冲区大小为 8192 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedOutputStream</span><span class="params">(OutputStream out)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(out, <span class="number">8192</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数，使用自定义的缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedOutputStream</span><span class="params">(OutputStream out, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(out);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bufferedreader">BufferedReader</h4>
<p>和 BufferedInputStream
一样，在内部维护了一个缓冲区，不同的是，这里是字符缓冲区。下面是源码中的一部分内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">    <span class="comment">// 内部缓冲区字符数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">char</span> cb[];</span><br><span class="line">    <span class="comment">// 默认缓冲区大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">defaultCharBufferSize</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line">    <span class="comment">// 构造函数，使用自定义的缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedReader</span><span class="params">(Reader in, <span class="type">int</span> sz)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.in = in;</span><br><span class="line">        cb = <span class="keyword">new</span> <span class="title class_">char</span>[sz];</span><br><span class="line">        nextChar = nChars = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数，使用默认缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedReader</span><span class="params">(Reader in)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(in, defaultCharBufferSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bufferedwriter">BufferedWriter</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">	<span class="comment">// 内部缓冲区字符数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> cb[];</span><br><span class="line">    <span class="comment">// 默认缓冲区大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">defaultCharBufferSize</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line">    <span class="comment">// 构造函数，使用默认缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedWriter</span><span class="params">(Writer out)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(out, defaultCharBufferSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数，使用自定义的缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedWriter</span><span class="params">(Writer out, <span class="type">int</span> sz)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(out);</span><br><span class="line">        <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.out = out;</span><br><span class="line">        cb = <span class="keyword">new</span> <span class="title class_">char</span>[sz];</span><br><span class="line">        nChars = sz;</span><br><span class="line">        nextChar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        lineSeparator = java.security.AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">sun</span>.security.action.GetPropertyAction(<span class="string">&quot;line.separator&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打印流">打印流</h2>
<p>打印流只有输出流(内存 -&gt; 文件)，没有输入流。</p>
<h3 id="printstream字节打印流">PrintStream(字节打印流)</h3>
<p>我们经常使用的 <code>System.out</code> 就是用于获取一个
<code>PrintStream</code> 对象，<code>System.out.print</code>
方法实际调用的是 <code>PrintStream</code> 对象的 <code>write</code>
方法。</p>
<p>默认情况下，<code>PrintStream</code>
输出数据的位置是标准输出，即显示器。</p>
<p>类图关系如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305142047733.png" style="zoom:50%;" /></p>
<h4 id="源码">源码</h4>
<p>下面是 <code>PrintStream</code> 的部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> <span class="keyword">extends</span> <span class="title class_">FilterOutputStream</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用的 write 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            s = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                ensureOpen();</span><br><span class="line">                textOut.write(s);</span><br><span class="line">                textOut.flushBuffer();</span><br><span class="line">                charOut.flushBuffer();</span><br><span class="line">                <span class="keyword">if</span> (autoFlush &amp;&amp; (s.indexOf(<span class="string">&#x27;\n&#x27;</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                    out.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            trouble = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="printwriter字符打印流">PrintWriter(字符打印流)</h3>
<p>包装了 <code>FileWriter</code> ，提供了更方便的方法来完成输出。</p>
<p>类图关系如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305142048308.png" style="zoom:50%;" /></p>
<h4 id="使用案例-11">使用案例</h4>
<p>这里我就给出一个案例来说明字符打印流要如何使用。</p>
<p><strong>需求：将 mrpersimmon-1.txt 中内容打印到 mrpersimmon-copy.txt
文件中。</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrintWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;mrpersimmon-1.txt&quot;</span>));</span><br><span class="line">         <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;mrpersimmon-copy.txt&quot;</span>)))) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">// 一次读取一行内容，为空时代表读取结束</span></span><br><span class="line">            pw.println(line); <span class="comment">// 换行并打印到指定文件中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305142105752.png" alt="运行结果" style="zoom:50%;" /></p>
<h2 id="随机访问流">随机访问流</h2>
<p>在本小结，主要介绍<strong>支持随意跳转到文件任意位置读写</strong>的
<code>RandomAccessFile</code> 类。磁盘文件都是随机访问的，但是与网络
Socket 通信的输入输出流却不是。当我们将已有文件作为 RandomAccessFile
打开时，这个文件不会被删除。</p>
<p>类关系如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305142114997.png" style="zoom:50%;" /></p>
<h3 id="构造函数">构造函数</h3>
<p>构造函数的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String name: 指定名称的文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(String name, String mode)</span></span><br><span class="line">    <span class="keyword">throws</span> FileNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>(name != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">File</span>(name) : <span class="literal">null</span>, mode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// String file: 指定文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode)</span></span><br><span class="line">        <span class="keyword">throws</span> FileNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重点介绍输入参数
<code>mode</code>(读写模式)。根据源码中的注释，读写模式共四种：</p>
<ol type="1">
<li><code>r</code>: 只读模式；</li>
<li><code>rw</code>: 读写模式；</li>
<li><code>rws</code>: 相较于
<code>rw</code>，还需要将对「文件内容」或「元数据」的每次更新同步写入底层存储设备；</li>
<li><code>rwd</code>: 相较于
<code>rw</code>，还要求对「文件内容」的每次更新都同步写入底层存储设备。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305142126492.png" style="zoom:50%;" /></p>
<p><strong>什么是「文件内容」？什么是「元数据」？</strong></p>
<p>「文件内容」指的是文件中实际保存的数据，「元数据」则是用来描述文件属性比如文件的大小信息、创建和修改时间。</p>
<p>rwd 相较于 rws 来说，可以减少执行 IO 操作次数。</p>
<h3 id="文件指针">文件指针</h3>
<p><code>RandomAccessFile</code>
中有一个文件指针用于表示<strong>下一个将要被写入或者读取的字节所处的位置</strong>。</p>
<p>我们可以通过 <code>seek(long pos)</code>
<strong>设置文件指针的偏移量</strong>(据文件开头 <code>pos</code>
个字节处)。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seek</span><span class="params">(<span class="type">long</span> pos)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Negative seek offset&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        seek0(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">seek0</span><span class="params">(<span class="type">long</span> pos)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>
<p>如果想要<strong>获取文件指针当前位置</strong>的话，可以使用
<code>getFilePointer()</code> 方法。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">getFilePointer</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>
<h3 id="常见方法">常见方法</h3>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 33%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>返回值</th>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>long</td>
<td>getFilePointer()</td>
<td>获取文件指针当前位置</td>
</tr>
<tr class="even">
<td>void</td>
<td>set(long pos)</td>
<td>设置文件指针的偏移量</td>
</tr>
<tr class="odd">
<td>long</td>
<td>length()</td>
<td>返回文件的长度</td>
</tr>
<tr class="even">
<td>int</td>
<td>read()</td>
<td>读取一个字节</td>
</tr>
<tr class="odd">
<td>int</td>
<td>read(byte[] b)</td>
<td>从该文件读取最多 <code>b.length</code>字节的数据到字节数组。</td>
</tr>
<tr class="even">
<td>int</td>
<td>read(byte[] b, int off, int len)</td>
<td>从该文件读取最多 <code>len</code>个字节的数据到字节数组。</td>
</tr>
<tr class="odd">
<td>String</td>
<td>readLine()</td>
<td>读取下一行文本。</td>
</tr>
<tr class="even">
<td>String</td>
<td>readUTF()</td>
<td>从该文件读取字符串。</td>
</tr>
<tr class="odd">
<td>void</td>
<td>write(byte[] b)</td>
<td>从指定的字节数组写入
<code>b.length</code>个字节到该文件，从当前文件指针开始。</td>
</tr>
<tr class="even">
<td>void</td>
<td>write(byte[] b, int off, int len)</td>
<td>从指定的字节数组写入 <code>len</code>个字节，从偏移量
<code>off</code>开始写入此文件。</td>
</tr>
<tr class="odd">
<td>void</td>
<td>write(int b)</td>
<td>将指定的字节写入此文件。</td>
</tr>
<tr class="even">
<td>void</td>
<td>writeUTF(String str)</td>
<td>以机器无关的方式使用 UTF-8 编码将字符串写入文件。</td>
</tr>
<tr class="odd">
<td>int</td>
<td>skipBytes(int n)</td>
<td>尝试跳过 <code>n</code> 字节的输入，丢弃跳过的字节。</td>
</tr>
</tbody>
</table>
<h3 id="使用案例-12">使用案例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRandomAccessFile</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;mrpersimmon.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// readLine() 读取一行文本</span></span><br><span class="line">        System.out.println(<span class="string">&quot;起始文件内容：&quot;</span> + raf.readLine());</span><br><span class="line">        raf.seek(<span class="number">0</span>); <span class="comment">// 设置文件指针偏移量为 0，回到起始位置</span></span><br><span class="line">        <span class="comment">// read() 读取一个字节</span></span><br><span class="line">        <span class="comment">// getFilePointer 获取文件指针当前位置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;读取前的偏移量：&quot;</span> + raf.getFilePointer() + <span class="string">&quot;，当前读取的字符：&quot;</span> + (<span class="type">char</span>) raf.read() + <span class="string">&quot;，读取后的偏移量：&quot;</span> + raf.getFilePointer());</span><br><span class="line">        raf.seek(<span class="number">6</span>); <span class="comment">// 设置文件指针偏移量为 6</span></span><br><span class="line">        System.out.println(<span class="string">&quot;读取前的偏移量：&quot;</span> + raf.getFilePointer() + <span class="string">&quot;，当前读取的字符：&quot;</span> + (<span class="type">char</span>) raf.read() + <span class="string">&quot;，读取后的偏移量：&quot;</span> + raf.getFilePointer());</span><br><span class="line">        raf.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;写入后的偏移量：&quot;</span> + raf.getFilePointer() + <span class="string">&quot;，当前读取的字符：&quot;</span> + (<span class="type">char</span>) raf.read() + <span class="string">&quot;，读取后的偏移量：&quot;</span> + raf.getFilePointer());</span><br><span class="line">        raf.seek(<span class="number">0</span>); <span class="comment">// 设置文件指针偏移量为 0，回到起始位置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前文件的内容为：&quot;</span> + raf.readLine());</span><br><span class="line">        raf.seek(<span class="number">0</span>); <span class="comment">// 设置文件指针偏移量为 0，回到起始位置</span></span><br><span class="line">        raf.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;); <span class="comment">// 覆盖数据</span></span><br><span class="line">        raf.seek(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;覆盖后的文件内容为：&quot;</span> + raf.readLine());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">起始文件内容：abcdefg</span><br><span class="line">读取前的偏移量：0，当前读取的字符：a，读取后的偏移量：1</span><br><span class="line">读取前的偏移量：6，当前读取的字符：g，读取后的偏移量：7</span><br><span class="line">写入后的偏移量：9，当前读取的字符：￿，读取后的偏移量：9</span><br><span class="line">当前文件的内容为：abcdefghi</span><br><span class="line">覆盖后的文件内容为：ABCdefghi</span><br></pre></td></tr></table></figure>
<h3 id="应用场景">应用场景</h3>
<p><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的
<strong>断点续传</strong> 。</p>
<p>何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p>
<p>该部分内容我们会在后续实战部分中，手写一个断点续传下载器进行详细讲解。</p>
<h2 id="综合应用案例">综合应用案例</h2>
<h3 id="案例-1格式化读取写入文本">案例 1：格式化读取写入文本</h3>
<h4 id="需求说明">需求说明</h4>
<ol type="1">
<li>给定一个 Employee 类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary; <span class="comment">// 薪水</span></span><br><span class="line">    <span class="keyword">private</span> LocalDate hireDay; <span class="comment">// 雇佣日期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">double</span> s, <span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        salary = s;</span><br><span class="line">        hireDay = LocalDate.of(year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LocalDate <span class="title function_">getHireDay</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加薪</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">raiseSalary</span><span class="params">(<span class="type">double</span> byPercent)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">raise</span> <span class="operator">=</span> salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        salary += raise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName()</span><br><span class="line">                + <span class="string">&quot;[name=&quot;</span> + name + <span class="string">&quot;,salary=&quot;</span> + salary + <span class="string">&quot;,hireDay=&quot;</span> + hireDay + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>我们需要按照指定格式写入到 <code>Employee.dat</code> 文件中。</li>
</ol>
<p>第一行数字是写入的记录数量。</p>
<p>指定格式：<code>姓名|薪水|入职时间</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Carl Cracker|75000.0|1987-12-15</span><br><span class="line">Harry Hacker|50000.0|1989-10-01</span><br><span class="line">Tony Tester|40000.0|1990-03-15</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>从 <code>Employee.dat</code> 文件中读取数据打印到控制台中。</li>
</ol>
<h4 id="代码-3">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Employee[] staff = <span class="keyword">new</span> <span class="title class_">Employee</span>[<span class="number">3</span>];</span><br><span class="line">        staff[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Carl Cracker&quot;</span>, <span class="number">75000</span>, <span class="number">1987</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line">        staff[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Harry Hacker&quot;</span>, <span class="number">50000</span>, <span class="number">1989</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">        staff[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Tony Tester&quot;</span>, <span class="number">40000</span>, <span class="number">1990</span>, <span class="number">3</span>, <span class="number">15</span>);</span><br><span class="line">        <span class="comment">// 按照指定格式写入到 `Employee.dat` 文件中。</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;Employee.dat&quot;</span>, String.valueOf(StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            out.println(staff.length);</span><br><span class="line">            <span class="keyword">for</span> (Employee e : staff) &#123;</span><br><span class="line">                out.println(e.getName() + <span class="string">&quot;|&quot;</span> + e.getSalary() + <span class="string">&quot;|&quot;</span> + e.getHireDay());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 `Employee.dat` 文件中读取数据打印到控制台中。</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Employee.dat&quot;</span>), String.valueOf(StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            in.nextLine();</span><br><span class="line">            Employee[] employees = <span class="keyword">new</span> <span class="title class_">Employee</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                employees[i] = readEmployee(in);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Employee e : employees) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">readEmployee</span><span class="params">(Scanner in)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">        <span class="comment">// split 方法的参数是一个描述分隔符的正则表达式。</span></span><br><span class="line">        <span class="comment">// 由于 &quot;|&quot; 在正则表达式中有特殊含义，所以需要 &quot;\&quot; 来转义，而 &quot;\&quot; 还需要一个 &quot;\&quot; 来转义。</span></span><br><span class="line">        <span class="comment">// 所以，表达式为 &quot;\\|&quot;。</span></span><br><span class="line">        String[] tokens = line.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> tokens[<span class="number">0</span>];</span><br><span class="line">        <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> Double.parseDouble(tokens[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">hireDate</span> <span class="operator">=</span> LocalDate.parse(tokens[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> hireDate.getYear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> hireDate.getMonthValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> hireDate.getDayOfMonth();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(name, salary, year, month, day);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行结果">运行结果</h4>
<ol type="1">
<li>工作目录中出现 <code>Employee.dat</code> 文件，有如下内容：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305162200702.png" style="zoom:50%;" /></p>
<ol start="2" type="1">
<li>打印到控制台的内容如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.Employee[name=Carl Cracker,salary=75000.0,hireDay=1987-12-15]</span><br><span class="line">io.Employee[name=Harry Hacker,salary=50000.0,hireDay=1989-10-01]</span><br><span class="line">io.Employee[name=Tony Tester,salary=40000.0,hireDay=1990-03-15]</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>在这一讲中，我们讲解了如何判断输入、输出流，字节流和字符流的区别和使用场景，缓冲流比普通流快的实际案例，什么是打印流，最后介绍了随机访问流。</p>
<p>在下一讲中，我们去看看设计模式是如何在 Java IO 中应用的。</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>JDK 8 API；</li>
<li>JDK 9 API；</li>
<li>Java核心技术·卷 II（原书第11版）高级特性;</li>
<li>JavaGuide；</li>
</ol>
<h2 id="更新日志">更新日志</h2>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>时间</th>
<th>更新内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2023.5.15</td>
<td>发布文章</td>
</tr>
<tr class="even">
<td>2023.5.16</td>
<td><strong>新增：</strong>获取用户工作目录，获取不同操作系统的文件分隔符，try-with-resource
自动关闭流，java.io.Closeable 接口扩展 java.lang.AutoCloseable
接口的原因，增加综合应用案例。<strong>修改：</strong>修改创建文件的使用案例，完善格式。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO 的设计模式(壹) —— 装饰器模式</title>
    <url>/article/d0d38443.html</url>
    <content><![CDATA[<p>在上一篇，我们知道了 Java IO
的基本使用，从本篇开始，我们一起来探究设计模式是如何在 Java IO
中应用的。首先，我们先要学习的是装饰器模式。</p>
<p>我相信，友好的讨论交流会让彼此快速进步！文章难免有疏漏之处，十分欢迎大家在评论区中批评指正。</p>
<span id="more"></span>
<h1 id="什么是装饰器模式">什么是装饰器模式</h1>
<p>装饰器模式通过<strong>组合替代继承</strong>的方式在<strong>不改变原始类的情况下添加增强功能</strong>，主要<strong>解决继承关系过于复杂的问题</strong>（Java
IO 就属于这种复杂情况）。</p>
<p>刚上来，我们先知道装饰器是干啥的，解决啥问题就行，具体的是如何做的，我们边分析边说。</p>
<h1 id="java-io-庞大的类库">Java IO 庞大的类库</h1>
<p>Java IO 的类库十分庞大，有 40 多个类，负责 IO
数据的读取和写入。我们可以从以下角度将其划分为四类，具体如下：</p>
<table>
<thead>
<tr class="header">
<th>（抽象基类）</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr class="even">
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody>
</table>
<p>针对不同的读取和写入场景，Java IO
又在四个父类基础上，扩展了很多子类。具体如下（只列举了一些常用的类）：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305171515063.png"
alt="IO 流常用类" />
<figcaption aria-hidden="true">IO 流常用类</figcaption>
</figure>
<h1 id="java-io-流的嵌套用法">Java IO 流的嵌套用法</h1>
<p>还记得我们在 Java IO
基础篇中流的使用案例吗？若要使用缓存字节输入流，我们需要在
BufferedInputStream 的构造函数中传递一个 FileInputStream
对象来使用（这就是，使用 BufferedInputStream 增强 FileInputStream
的功能）。具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> </span><br><span class="line">     	<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span> (bis.read(b) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或许，你可能想为什么 Java IO 不设计一个继承 FileInputStream
并且支持缓存的 BufferedFileInputStream 类呢？</p>
<p>如果是这样的话，我们岂不是可以直接创建一个 BufferedFileInputStream
类对象，支持缓存并且可以打开文件读取数据，这样多省事简单啊。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedFileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">   <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">128</span>];</span><br><span class="line">   <span class="keyword">while</span> (bis.read(b) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们的这种思路就是基于继承的设计方案了。</p>
<h1 id="基于继承的设计方案">基于继承的设计方案</h1>
<p>如果说 <code>InputStream</code> 只有一个子类
<code>FileInputStream</code> 的话，那么我们在 <code>InputStream</code>
基础上，再设计一个孙子类
<code>BufferedFileInputStream</code>，也算是可以，毕竟继承结构比较简单，能够接受。</p>
<p>然而，事实上，我们在上面的常用类图中也看到了，继承
<code>InputStream</code> 的子类非常多，那么我们就需要给每一个
<code>InputStream</code>
子类都派生一个支持缓存读取的子类，这数量太庞大了！</p>
<p>而且，支持缓存只是拓展功能之一，我们还要对其他功能进行增强，比如
<code>DataInputStream</code> 类，它支持按照所有 Java
基本数据类型来读取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们继续按照继承的方式来实现的话，那我们就需要派生出
<code>DataFileInputStream</code>、<code>DataPipedInputStream</code>
等类。</p>
<p>如果我们还需要既支持缓存、又支持按照基本数据类型读取的类，那就要再继续派生出
<code>BufferedDataFileInputStream</code>、<code>BufferedDataPipedInputStream</code>
等超多的类。</p>
<p>现在只是附加了两个增强功能，如果要添加更多增强功能，那就会导致类数量爆炸，类的继承结构将变得无比复杂，代码既不好拓展，也不好维护。</p>
<p>那有没有什么办法可以解决这个问题呢？当然有，我们可以<strong>使用组合（composition）和委托（delegation）达到继承行为的效果</strong>。这种方案符合设计原则：<strong>多用组合，少用继承</strong>。</p>
<p>基于继承的设计方案，所有的子类都会继承到相同的行为。而使用组合和委托，我们可以动态地组合对象，可以写新的代码添加新的功能，而无需修改现有代码，引进
bug
的机会将大幅减少。这也符合另一个设计原则：<strong>开闭原则，类应该对扩展开放，对修改关闭。</strong></p>
<h1 id="基于装饰器模式的设计方案">基于装饰器模式的设计方案</h1>
<h2 id="装饰器模式的标准类图">装饰器模式的标准类图</h2>
<p>由于使用继承实现的结构过于复杂，Java IO
采用了基于装饰器模式的设计方案。我们先来看看装饰器模式的标准类图是什么样子的。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305172026182.png"
alt="装饰器模式" />
<figcaption aria-hidden="true">装饰器模式</figcaption>
</figure>
<h2 id="从类图角度分析-java-io-是如何使用装饰者模式的">从类图角度分析
Java IO 是如何使用装饰者模式的</h2>
<p>首先我们先从类图的角度来看看 Java IO 是如何使用装饰者模式的。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305172345467.png"
alt="Java IO 是如何使用装饰者模式的" />
<figcaption aria-hidden="true">Java IO
是如何使用装饰者模式的</figcaption>
</figure>
<h2 id="从源码角度分析-java-io-是如何使用装饰者模式的">从源码角度分析
Java IO 是如何使用装饰者模式的</h2>
<p>我们再从源码的角度去查看 Java IO 是如何使用装饰者模式的。</p>
<h3 id="inputstream抽象组件">InputStream（抽象组件）</h3>
<p>下面是简化后的 InputStream
源码，它是一个抽象类，作为一个抽象组件。我们具体看 read() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 具体的实现逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="fileinputstream-具体组件">FileInputStream (具体组件)</h3>
<p>FileInputStream 继承自
InputStream，<strong>有公有的构造方法可以直接使用，也可以被装饰者包起来使用。</strong>功能函数的实现逻辑与
InputStream 的实现逻辑不同，是新的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="built_in">this</span>(name != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">File</span>(name) : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 代码略...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(FileDescriptor fdObj)</span> &#123;</span><br><span class="line">        <span class="comment">// 代码略...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 新行为，没有调用抽象组件的 read() 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 新行为，没有调用抽象组件的 read(byte b[]) 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 新行为，没有调用抽象组件的 read(byte b[], int off, int len) 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="filterinputstream抽象的装饰者">FilterInputStream（抽象的装饰者）</h3>
<p>下面是 <code>FilterInputStream</code> 源码，它继承了
<code>InputStream</code>，作为一个装饰者，它保存了抽象组件的引用。<strong>构造函数声明为
<code>protected</code>，表明用户不能直接构造该类的对象，只能构造该类的子类对象。</strong></p>
<p><code>FilterInputStream</code> 没有对 <code>InputStream</code> 的
<code>read()</code> 进行增强，但是还是将其重新实现了一遍，简单地包裹了对
<code>InputStream</code> 对象的函数调用，委托给传递进来的
<code>InputStream</code> 对象来完成。</p>
<p>请务必查看代码中的关键注释！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in; <span class="comment">// 保存抽象组件组件的引用</span></span><br><span class="line">    <span class="comment">// 构造函数声明为 protected</span></span><br><span class="line">    <span class="comment">// 表明用户不能直接构造该类的对象，只能构造该类的子类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">FilterInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接调用了抽象组件的 read() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> in.read(); <span class="comment">// 委托给传递进来的 InputStream 对象来完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接调用了抽象组件的 read(byte b[], int off, int len) 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> in.read(b, off, len); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="bufferedinputstream具体的装饰者">BufferedInputStream（具体的装饰者）</h3>
<p><code>BufferedInputStream</code> 继承了
<code>FilterInputStream</code>，作为一个具体的装饰者，它增强了
<code>read()</code>
的功能，添加了缓存功能。请务必查看代码中的关键注释！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in); <span class="comment">// 记录装饰者所包着的抽象组件</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在旧方法的基础上实现了缓存功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">            fill();</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在旧方法的基础上实现了缓存功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ... 具体逻辑省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="pushbackinputstream具体的装饰者">PushbackInputStream（具体的装饰者）</h3>
<p>和 <code>BufferedInputStream</code> 一样，继承了
<code>FilterInputStream</code>，它添加了一种在读取输入流时将数据“推回”流中的功能，从而可以重新读取该数据。请务必查看代码中的关键注释！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PushbackInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">PushbackInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(in, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PushbackInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in); <span class="comment">// 记录装饰者所包着的抽象组件</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">        <span class="built_in">this</span>.pos = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 功能增强</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; buf.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> buf[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.read(); <span class="comment">// 旧的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 功能增强</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 省略了部分代码，这些代码用于增强...</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            len = <span class="built_in">super</span>.read(b, off, len); <span class="comment">// 旧的方法</span></span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> avail == <span class="number">0</span> ? -<span class="number">1</span> : avail;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> avail + len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> avail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以知道，为了避免代码重复，Java IO
抽象出来一个装饰者父类
<code>FilterInputStream</code>，<code>InputStream</code>
的所有具体的装饰器类（<code>BufferedInputStream</code>、<code>DataInputStream</code>、<code>PushbackInputStream</code>）都继承自这个装饰器父类。具体的装饰器类只需要实现它需要增强的方法就可以了，其他方法都继承装饰器父类的默认实现。</p>
<h2 id="装饰器模式的代码结构">装饰器模式的代码结构</h2>
<p>我们将上述的内容整理出来一个代码结构，具体如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类也可以替换成接口</span></span><br><span class="line"><span class="comment">// 抽象组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteComponent</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 新的实现逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象装饰器（具体装饰器的父类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Component c; <span class="comment">// 组合</span></span><br><span class="line">    <span class="comment">// 无法构造自己的对象，只能构造自己的子类对象</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Decorator</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        c.f(); <span class="comment">// 委托</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体装饰器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecoratorA</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(c); <span class="comment">// 通过构造器组合抽象组件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 功能增强代码</span></span><br><span class="line">        <span class="built_in">super</span>.f(); <span class="comment">// 委托</span></span><br><span class="line">        <span class="comment">// 功能增强代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="疑问解答时间">疑问解答时间</h1>
<h2
id="为什么装饰器模式还是用到继承了呢不是说要利用组合取代继承吗">为什么装饰器模式还是用到继承了呢，不是说要利用组合取代继承吗？</h2>
<p>在之前的基于继承的设计方案中，我们谈到使用继承的方案会导致类数量爆炸，类的继承结构将变得无比复杂，代码既不好拓展，也不好维护。</p>
<p>在装饰器模式中，使用继承的主要目的是让装饰器和抽象组件是一样的类型，也就是要有共同的超类，也就是<strong>使用继承达到「类型匹配」</strong>，而不是利用继承获得「行为」。</p>
<p>当我们将装饰器与组件组合时，就是在加入新的行为。这种新的行为并不是继承自超类，而是由组合对象得来的（在代码结构中已给出了明确注释）。</p>
<p>另外，如果是基于继承的设计方案，那么所有的类的行为只能在编译时静态决定，也就是说，行为不是来自于超类，就是子类覆盖后的版本。如果需要新的行为，必须修改现有的代码，这不符合开放关闭原则。</p>
<p>而在装饰器模式中，我们利用组合，可以把装饰器混合使用，而且，可以在任何时候，实现新的装饰器增加新的行为。</p>
<h2 id="为什么-component-设计成一个抽象类而不是一个接口呢">为什么
Component 设计成一个抽象类，而不是一个接口呢？</h2>
<p>通常装饰器模式是采用抽象类，在 Java
中也可以使用接口。文中给出的代码结构是从源码中提取而来的。</p>
<h1 id="总结一下">总结一下</h1>
<ul>
<li><p>装饰器模式主要用于解决继承关系复杂的问题，通过组合和委托来替代继承。</p></li>
<li><p>装饰器模式的主要作用就是给组件添加增强功能，可以在组件功能代码的前面、后面添加自己的功能代码，甚至可以将组件的功能代码完全替换掉。</p></li>
<li><p>装饰器和具体的组件都继承相同的抽象类或接口（组件），所以可以使用无数个装饰器包装一个具体的组件。</p></li>
<li><p>装饰器模式也是有问题的，它会导致设计中出现许多小类，如果过度使用，会让程序变得很复杂。</p></li>
</ul>
<h1 id="练习题">练习题</h1>
<p>现在我们已经知道了装饰器模式，也看过 Java IO
的类图和源码，那么接下来我们来编写一个自己的输入装饰器吧。</p>
<h2 id="需求">需求</h2>
<p>编写一个装饰器，把输入流内的所有大写字符转成小写。比如，"HELLO
WORLD!"，装饰器会把它转换成 "hello world!"</p>
<h2 id="代码实现">代码实现</h2>
<p>首先，我们得扩展 <code>FilterInputStream</code>，这是所有
<code>InputStream</code> 的抽象装饰器。</p>
<p>我们必须实现两个 <code>read()</code>
方法，一个针对字节，一个针对字节数组，把每个大写字符的字节转成小写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LowerCaseInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LowerCaseInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in); <span class="comment">// 保存 FilterInputStream 的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="built_in">super</span>.read();</span><br><span class="line">        <span class="keyword">return</span> (c == -<span class="number">1</span> ? c : Character.toLowerCase((<span class="type">char</span>) c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理字节数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">super</span>.read(b, off, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> off; i &lt; off + result; i++) &#123;</span><br><span class="line">            b[i] = (<span class="type">byte</span>) Character.toLowerCase((<span class="type">char</span>) b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试一下">测试一下</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span></span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">LowerCaseInputStream</span>(</span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)))) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((c = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>) c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test.txt 文件中保存着 "HELLO WORLD!"</p>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world!</span><br></pre></td></tr></table></figure>
<hr />
<p>好啦，以上就是本篇文章的全部内容了。我们讲解了什么是装饰器模式，装饰器模式的标准类图、代码结构，知道了
Java IO 是如何使用装饰器模式的。</p>
<p>希望以上内容对你有帮助，一起加油！</p>
<h1 id="参考资料">参考资料</h1>
<ol type="1">
<li>Head First 设计模式</li>
<li>设计模式之美</li>
<li><a
href="http://cecs.wright.edu/~tkprasad/courses/ceg860/paper/node26.html">Patterns
in Java APIs</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树与递归的框架思维「浓缩版」</title>
    <url>/article/ebfb7429.html</url>
    <content><![CDATA[<p>本文是 <a
href="https://www.mrpersimmon.top/article/893f0705.html">二叉树与递归的框架思维「详解版」</a>的关键知识总结。</p>
<p><strong>二叉树解题思维分两类：</strong></p>
<ol type="1">
<li><p><strong>是否可以通过遍历一遍二叉树得到答案？</strong></p>
<p>如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫
「遍历」的思维模式。</p></li>
<li><p><strong>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？</strong></p>
<p>如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p></li>
</ol>
<p><strong>无论哪种思维模式，我们都需要思考：</strong></p>
<p><strong>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？</strong>其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</p>
<p><strong>二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。</strong></p>
<span id="more"></span>
<h3 id="二叉树的重要性">二叉树的重要性</h3>
<ul>
<li>快速排序的本质是二叉树的前序遍历。</li>
<li>归并排序的本质是二叉树的后序遍历。</li>
</ul>
<h3 id="深入理解前中后序">深入理解前中后序</h3>
<h4 id="二叉树遍历框架">二叉树遍历框架</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。</strong></p>
<p><strong>前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，</strong>你把代码写在不同位置，代码执行的时机也不同：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/1.jpeg" alt="代码执行时机" style="zoom:50%;" /></p>
<h4 id="前中后序位置的特殊性">前中后序位置的特殊性</h4>
<p>前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点，绝不仅仅是三个顺序不同的
List。</p>
<ul>
<li>前序位置的代码在刚刚进入一个二叉树节点的时候执行；</li>
<li>后序位置的代码在将要离开一个二叉树节点的时候执行；</li>
<li>中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/2.jpeg" alt="二叉树的前中后序的位置" style="zoom:30%;" /></p>
<p><strong>每个节点都有唯一属于自己的前中后序位置</strong>，因此前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点。</p>
<p>这也就是为什么多叉树没有中序位置的原因，多叉树节点没有「唯一」的中序遍历位置。</p>
<p><strong>二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。</strong></p>
<hr />
<h3 id="两种解题思路">两种解题思路</h3>
<ol type="1">
<li><strong>是否可以通过遍历一遍二叉树得到答案。</strong>如果可以，函数签名一般是
<code>void traverse(...)</code>，没有返回值，靠更新外部变量来计算结果。</li>
<li><strong>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案。</strong>函数名根据该函数具体功能而定，而且一般会有返回值，返回值是子问题的计算结果。</li>
<li><strong>无论使用哪种思路，都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。</strong></li>
</ol>
<p>题目 1：<a
href="https://www.nowcoder.com/practice/8a2b2bf6c19b4f23a9bdb9b233eefa73">牛客BM28
二叉树的最大深度</a></p>
<p>题目 2：二叉树的前序遍历</p>
<hr />
<h3 id="后序位置的特殊之处">后序位置的特殊之处</h3>
<h4 id="中序和前序位置">中序和前序位置</h4>
<p><strong>中序位置主要用在 BST 场景中，完全可以把 BST
的中序遍历认为是遍历有序数组。</strong></p>
<p>前序位置没啥特殊，习惯将对前中后序位置不敏感的代码写在前序位置。</p>
<h4 id="后序位置">后序位置</h4>
<p><strong>前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/2.jpeg" alt="二叉树的前中后序的位置" style="zoom:30%;" /></p>
<p>这意味着<strong>前序位置的代码只能从函数参数中获取父节点传递来的数据</strong>，而<strong>后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。</strong></p>
<p>题目 1：把根节点看作第 1 层，如何打印出每一个节点所在的层数？</p>
<p>题目 2：如何打印出每个节点的左右子树各有多少节点？</p>
<p>题目 3：<a
href="https://leetcode.cn/problems/diameter-of-binary-tree">力扣第 543
题「二叉树的直径」</a></p>
<hr />
<h3 id="层序遍历">层序遍历</h3>
<h4 id="代码框架">代码框架</h4>
<p>二叉树题型主要用来培养递归思维，而层序遍历属于迭代遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    <span class="comment">// 从上到下遍历二叉树每一层</span></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>)</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>)</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/1-20230408150000724.jpeg" alt="层序遍历" style="zoom:40%;" /></p>
<p><strong>BFS</strong>
算法框架就是从二叉树的层序遍历扩展而来，常用于<strong>求无权图的最短路径问题</strong>。</p>
<p><strong>框架还可以灵活修改，题目不需要记录层数（步数）时，可以去掉上述框架中的
for 循环</strong>，比如 Dijkstra
算法中计算加权图的最短路径问题，详细探讨了 BFS 算法的扩展。</p>
<h3 id="参考资料">参考资料</h3>
<ol type="1">
<li>labuladong 的算法小抄</li>
<li>牛客网</li>
<li>力扣网</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
        <category>算法框架</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法框架</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树与递归的框架思维「详解版」</title>
    <url>/article/9a51cfe6.html</url>
    <content><![CDATA[<p><strong>二叉树解题思维分两类：</strong></p>
<ol type="1">
<li><p><strong>是否可以通过遍历一遍二叉树得到答案？</strong></p>
<p>如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫
「遍历」的思维模式。</p></li>
<li><p><strong>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？</strong></p>
<p>如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p></li>
</ol>
<p><strong>无论哪种思维模式，我们都需要思考：</strong></p>
<p><strong>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？</strong>其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</p>
<p>本文解决了如下题目：</p>
<p><a
href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">力扣第
104 题「二叉树的最大深度」</a></p>
<p><a
href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">力扣第
144 题「二叉树的前序遍历」</a></p>
<p><a href="https://leetcode.cn/problems/diameter-of-binary-tree">力扣第
543 题「二叉树的直径」</a></p>
<p><a
href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">剑指
Offer 第 55 题 「二叉树的深度」</a></p>
<span id="more"></span>
<h3 id="二叉树的重要性">二叉树的重要性</h3>
<h4 id="快速排序和归并排序的本质">快速排序和归并排序的本质</h4>
<ul>
<li><p><strong>快速排序：二叉树前序遍历</strong></p></li>
<li><p><strong>归并排序：二叉树后序遍历</strong></p></li>
</ul>
<h4 id="快速排序的逻辑和框架">快速排序的逻辑和框架</h4>
<h5 id="算法逻辑">算法逻辑</h5>
<p>若要对 <code>nums[lo...hi]</code>
进行排序，我们先找一个<strong>分界点 p</strong>，通过交换元素使得
<code>nums[lo...p-1]</code> 都 <code>&lt;= nums[p]</code>，且
<code>nums[p+1...hi]</code> 都 <code>&gt; nums[p]</code>，然后递归地去
<code>nums[lo...p-1]</code> 和 <code>nums[p+1...hi]</code>
中寻找新的分界点，最后这个数组就被排序了。</p>
<h5 id="代码框架">代码框架</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：排序 nums[lo...hi]</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="comment">/****** 前序遍历位置 ******/</span></span><br><span class="line">    <span class="comment">// 通过交换元素构建分界点 p</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line">    <span class="comment">/************************/</span></span><br><span class="line">    </span><br><span class="line">    sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>先构造分界点，然后去左右子数组构造分界点，这不就是一个二叉树的<u>前序遍历</u>吗？</strong></p>
<h4 id="归并排序的逻辑和框架">归并排序的逻辑和框架</h4>
<h5 id="算法逻辑-1">算法逻辑</h5>
<p>若要对 <code>nums[lo...hi]</code> 进行排序，我们先对
<code>nums[lo...mid]</code> 进行排序，再对 <code>nums[mid+1...hi]</code>
排序，最后把这两个有序的子数组合并成整个数组就排好序了。</p>
<h5 id="代码框架-1">代码框架</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：排序 nums[lo...hi]</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + ((hi - lo) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 排序 nums[lo...mid]</span></span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    <span class="comment">// 排序 nums[mid+1...hi]</span></span><br><span class="line">    sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/****** 后序位置 ******/</span></span><br><span class="line">    <span class="comment">// 合并 nums[lo...mid] 和 nums[mid+1...hi]</span></span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">    <span class="comment">/********************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>先对左右子数组进行排序，然后合并（类似合并有序链表的逻辑），这不就是<u>二叉树的后序遍历</u>嘛，同时也是<u>分治算法</u>思想的体现呀。</strong></p>
<p>二叉树的算法思想运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树问题。</p>
<hr />
<h3 id="深入理解前中后序">深入理解前中后序</h3>
<h4 id="三个问题">三个问题</h4>
<p>先思考 3 个问题：</p>
<ol type="1">
<li>二叉树的前中后序遍历是什么？仅仅是三个顺序不同的 List 吗？</li>
<li>后序遍历有什么特殊之处？</li>
<li>多叉树为什么没有中序遍历？</li>
</ol>
<h5 id="二叉树遍历框架">二叉树遍历框架</h5>
<p>首先，看一下二叉树的遍历框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先不管所谓前中后序，单看 traverse 函数，它在做什么事情？</p>
<p>其实，<strong>它就是一个能够遍历二叉树所有节点的一个函数</strong>，和遍历数组或者链表本质上没有区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代遍历数组</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历数组</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == arr.length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    traverse(arr, i + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代遍历单链表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历单链表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    traverse(head.next);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单链表和数组的遍历可以是迭代的，也可以是递归地，<strong>二叉树这种结构无非就是二叉链表</strong>，由于没办法简单改写成迭代形式，所以一般说<strong>二叉树的遍历框架都是指递归的形式</strong>。</p>
<p>值得注意的是，<strong>只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。</strong></p>
<p><strong>所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，</strong>那么进一步，你把代码写在不同位置，代码执行的时机也不同：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/1.jpeg" alt="代码执行时机" style="zoom:50%;" /></p>
<p><strong>如果让你<u>倒序打印</u>一条单链表上所有节点的值，你如何实现？</strong></p>
<p>如果使用递归来实现的话，可以利用后序位置来操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    traverse(head.next);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    print(head.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上面那张图，可以知道这段代码之所以能实现倒序打印单链表的本质是：<strong>利用递归的堆栈帮你实现了倒序遍历的效果。</strong></p>
<h5 id="前中后序位置的特殊性">前中后序位置的特殊性</h5>
<p>回到二叉树，二叉树不过多了一个中序位置罢了。</p>
<p><strong>前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点</strong>，绝不仅仅是三个顺序不同的
List。</p>
<ul>
<li>前序位置的代码在刚刚进入一个二叉树节点的时候执行；</li>
<li>后序位置的代码在将要离开一个二叉树节点的时候执行；</li>
<li>中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。</li>
</ul>
<p>注意文中的用词，一直在强调<strong>前中后序「位置」</strong>，就是要和常说的前中后序「遍历」有所区别：我们可以在前序位置写代码，往一个
List
里面塞元素，那最后得到的就是前序遍历结果；但并不是说你就不可以写更复杂的代码做更复杂的事。</p>
<p>画成图，前中后序三个位置在二叉树上的样子如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/2.jpeg" alt="二叉树的前中后序的位置" style="zoom:30%;" /></p>
<p>可以发现，<strong>每个节点都有唯一属于自己的前中后序位置</strong>，因此前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点。</p>
<h5 id="多叉树没有中序位置的原因">多叉树没有中序位置的原因</h5>
<p>这也就是<strong>为什么多叉树没有中序位置</strong>，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。</p>
<p><strong>二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。</strong></p>
<p>图论算法将二叉树的遍历框架扩展到了图，并以遍历为基础实现了图论的各种经典算法。</p>
<hr />
<h3 id="两种解题思路">两种解题思路</h3>
<p>二叉树题目的递归解法可以分两类思路，<strong>第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，</strong>这两类思路分别对应着<strong>回溯算法核心框架</strong>和<strong>动态规划核心框架</strong>。</p>
<blockquote>
<p><strong>函数命名习惯</strong></p>
<p>二叉树中用<strong>遍历思路解题</strong>时函数签名一般是<code>void traverse(...)</code>，没有返回值，靠更新外部变量来计算结果。而用<strong>分解问题思路解题</strong>时函数名根据该函数具体功能而定，而且一般会有返回值，返回值是子问题的计算结果。</p>
<p>与此对应，在<strong>回溯算法核心框架</strong>中给出的函数签名一般也是没有返回值的
<code>void backtrack(...)</code>。而在<strong>动态规划核心框架</strong>中给出的函数签名是带有返回值的
<code>dp</code> 函数。这也说明了它俩和二叉树之间有联系。</p>
</blockquote>
<h4
id="从二叉树的最大深度看两种解题思路">从二叉树的最大深度看两种解题思路</h4>
<p>牛客<a
href="https://www.nowcoder.com/practice/8a2b2bf6c19b4f23a9bdb9b233eefa73">BM28
二叉树的最大深度</a>，所谓最大深度就是树的根节点到最远叶子节点的最长路径上的节点数，比如输入这棵二叉树，算法应该返回
3：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/tree.jpg" alt="二叉树的最大深度" style="zoom:70%;" /></p>
<h5 id="遍历二叉树得出答案">遍历二叉树得出答案</h5>
<p>思路：遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度，这就是遍历二叉树计算答案的思路。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录最大深度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 记录遍历到的节点的深度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树遍历框架</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    depth++;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 到达叶子节点，更新最大深度</span></span><br><span class="line">        res = Math.max(res, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    depth--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么需要再前序位置增加 <code>depth</code>，在后序位置减小
<code>depth</code> ?</p>
<p>因为前面说了，前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，<code>depth</code>
记录当前递归到的节点深度，你把 <code>traverse</code>
理解成在二叉树上游走的一个指针，所以当然要这样维护。</p>
<p>至于对 <code>res</code>
的更新，你放到前中后序位置都可以，只要保证在进入节点之后，离开节点之前（即
<code>depth</code> 自增之后，自减之前）就行了。</p>
<h5 id="分解问题得出答案">分解问题得出答案</h5>
<p>当然，你也很容易发现一棵二叉树的最大深度可以通过子树的最大深度推导出来，这就是<strong>分解问题计算答案的思路</strong>。</p>
<p>解法代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 利用定义，计算左右子树的最大深度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="comment">// 整棵树的最大深度 = 左右子树的最大深度取最大值 + 1 (根节点自己)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要明确递归函数的定义，这个解法也不难理解，但<strong>为什么主要的代码逻辑集中在后序位置？</strong></p>
<p>因为这个思路正确的核心在于，你确实可以通过子树的最大深度推导出原树的深度，所以当然要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置。</p>
<h4 id="二叉树的前序遍历">二叉树的前序遍历</h4>
<p>如果理解了最大深度这个问题的两种思路，那么我们在回头看看最基本的二叉树前中后序遍历，比如获取前序遍历结果。</p>
<h5 id="遍历二叉树得出答案-1">遍历二叉树得出答案</h5>
<p>最熟悉的解法就是用「遍历」的思路：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 返回前序遍历结果</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">preorderTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二叉树遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    res.add(root);</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分解问题得出答案-1">分解问题得出答案</h5>
<p>那么，能否使用「分解问题」的思路，来计算前序遍历的结果？</p>
<p>换句话说，不要用像 <code>traverse</code>
这样的辅助函数和任何外部变量，单纯用题目给的
<code>preorderTraverse</code> 函数递归解题。</p>
<p>我们知道前序遍历的特点是，根节点的值排在首位，接着是左子树的前序遍历结果，最后是右子树的遍历结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/3.jpeg" alt="img" style="zoom:50%;" /></p>
<p>那么，这样就可以分解问题了。</p>
<p><strong>一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 +
右子树的前序遍历结果。</strong></p>
<p>所以，就可以这样实现前序遍历算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">preorderTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 前序遍历的结果，root.val 在第一个</span></span><br><span class="line">    res.add(root.val);</span><br><span class="line">    <span class="comment">// 利用函数定义，后面接着左子树的前序遍历结果</span></span><br><span class="line">    res.addAll(preorderTraverse(root.left));</span><br><span class="line">    <span class="comment">// 利用函数定义，后面接着右子树的前序遍历结果</span></span><br><span class="line">    res.addAll(preorderTraverse(root.right));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序和后序遍历也是类似的，只要把 <code>add(root.val)</code>
放到中序和后序对应的位置就行了。</p>
<p><strong>这个解法短小精干，但为什么不常见呢？</strong></p>
<p>一个原因是<strong>这个算法的复杂度不好把控</strong>，比较依赖语言特性。</p>
<p>Java 的话，无论 ArrayList 还是 LinkedList，<code>addAll</code>
方法的复杂度都是 <span
class="math inline">\(O(N)\)</span>，所以总体的最坏时间复杂度会达到
<span class="math inline">\(O(N^2)\)</span>，除非你自己实现一个复杂度为
<span class="math inline">\(O(1)\)</span> 的 <code>addAll</code>
方法，底层用链表是可以做到的，因为多条链表只要简单的指针操作就能连接起来。</p>
<p>当然，最主要的原因还是因为教科书上从来没这么教过...</p>
<h5 id="二叉树题目的通用思考过程">二叉树题目的通用思考过程</h5>
<p>综上，遇到一道二叉树的题目时的通用思考过程是：</p>
<ol type="1">
<li><strong>是否可以通过遍历一遍二叉树得到答案？</strong>如果可以，用一个
traverse 函数配合外部变量来实现。</li>
<li><strong>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？</strong>如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。</li>
<li><strong>无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。</strong></li>
</ol>
<hr />
<h3 id="后序位置的特殊之处">后序位置的特殊之处</h3>
<h4 id="中序和前序位置">中序和前序位置</h4>
<p>说后序位置之前，先简单说下中序和前序。</p>
<p><strong>中序位置主要用在 BST 场景中，你完全可以把 BST
的中序遍历认为是遍历有序数组。</strong></p>
<p>前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。</p>
<h4 id="后序位置">后序位置</h4>
<p>你可以发现，<strong>前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/2-20230407201904428.jpeg" alt="二叉树的前中后序位置" style="zoom:30%;" /></p>
<p>这不奇怪，因为本文开头就说了前序位置是刚刚进入节点时刻，后序位置是即将离开节点的时刻。</p>
<p>但这里面大有玄妙，<strong>这意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。</strong></p>
<h5 id="两个简单问题">两个简单问题</h5>
<p>举一个具体例子，现在给你一棵二叉树，有两个简单问题：</p>
<ol type="1">
<li>如果把根节点看作第 1 层，如何打印出每一个节点所在的层数？</li>
<li>如何打印出每个节点的左右子树各有多少节点？</li>
</ol>
<p>解决第一个问题的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;节点 %s 在第 %d 层&quot;</span>, root, level);</span><br><span class="line">    traverse(root.left, level + <span class="number">1</span>);</span><br><span class="line">    traverse(root.right, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">traverse(root, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>解决第二个问题的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树，返回这棵二叉树的节点总数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> count(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> count(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点&quot;</span>,</span><br><span class="line">            root, leftCount, rightCount);</span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个问题的根本区别在于：<strong>一个节点在第几层，你从根节点遍历过来的过程就能顺带记录，用递归函数的参数就能传递下去；而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚，然后通过递归函数的返回值拿到答案。</strong></p>
<p>结合这两个简单的问题，可以发现后序位置的特点，<strong>只有后序位置才能通过返回值获取子树的信息。</strong></p>
<p>那么换句话说，<strong>一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。</strong></p>
<h5 id="二叉树的直径">二叉树的直径</h5>
<p>下面看一下<a
href="https://leetcode.cn/problems/diameter-of-binary-tree">力扣第 543
题「二叉树的直径」</a>，计算一棵二叉树的最长直径长度。</p>
<p>所谓二叉树的直径长度，就是任意两个节点之间的路径长度。最长直径并不一定要穿过根节点，比如下面这棵二叉树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/tree1.png" alt="二叉树的直径" style="zoom:60%;" /></p>
<p>它的最长直径是 3，即 [4,2,1,3]，[4,2,1,9] 或者 [5,2,1,3]
这几条直径的长度。</p>
<p>解决这题的关键在于，<strong>每一条二叉树的直径长度，就是一个节点的左右子树的最大深度之和。</strong></p>
<p>现在让我求整棵树中的最长直径，那直截了当的思路就是遍历整棵树中的每个节点，然后通过每个节点的左右子树的最大深度算出每个节点的直径，最后把所有直径求个最大值即可。</p>
<p>最大深度的算法已经实现过了，上述思路可以写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录最大直径的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDiameter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 对每个节点计算直径，求最大直径</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历二叉树</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 对每个节点计算直径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">myDiameter</span> <span class="operator">=</span> leftMax + rightMax;</span><br><span class="line">        <span class="comment">// 更新全局最大直径</span></span><br><span class="line">        maxDiameter = Math.max(maxDiameter, myDiameter);</span><br><span class="line">        </span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算二叉树的最大深度</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个解法是正确的，但是运行时间很长，原因也很明显，<code>traverse</code>
遍历每个节点的时候还会调用递归函数 <code>maxDepth</code>，而
<code>maxDepth</code> 是要遍历子树的所有节点的，所以最坏时间复杂度是
<span class="math inline">\(O(N^2)\)</span>。</p>
<p>这就出现了刚才探讨的情况，<strong>前序位置无法获取子树信息，所以只能让每个节点调用
<code>maxDepth</code> 函数去算子树的深度。</strong></p>
<p>那如何优化？</p>
<p>我们应该把计算直径的逻辑放在后序位置，准确说应该是放在
<code>maxDepth</code> 的后序位置，因为 <code>maxDepth</code>
的后序位置是知道左右子树的最大深度的。</p>
<p>优化后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录最大直径的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDiameter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 后序位置，顺便计算最大直径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">myDiameter</span> <span class="operator">=</span> leftMax + rightMax;</span><br><span class="line">        maxDiameter = Math.max(maxDiameter, myDiameter);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次，时间复杂度只有 <code>maxDepth</code> 函数的 <span
class="math inline">\(O(N)\)</span> 了。</p>
<p>讲到这里，照应一下前文：<strong>遇到子树问题，首先想到的是给函数设置返回值，然后在后序位置做文章。</strong></p>
<blockquote>
<p>请思考一下，运用后序遍历的题目使用的是「遍历」思路还是「分解问题」思路？</p>
<p>使用了「分解问题」的思路。因为当前节点接收并利用了子树返回的信息，这就意味着你把原问题分解成了当前节点
+ 左右子树的子问题。</p>
</blockquote>
<hr />
<h3 id="层序遍历">层序遍历</h3>
<h4 id="代码框架-2">代码框架</h4>
<p><strong>二叉树题型主要用来培养递归思维，而层序遍历属于迭代遍历</strong>，也比较简单，下面是代码框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树的根节点，层序遍历这棵二叉树</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的 while 循环和 for 循环分管从上到下和从左到右的遍历：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/1-20230408150000724.jpeg" alt="层序遍历" style="zoom:40%;" /></p>
<p><strong>BFS
算法框架</strong>就是从二叉树的层序遍历扩展出来的，常用于<strong>求无权图的最短路径</strong>问题。</p>
<p>当然，这个框架还可以灵活修改，题目不需要记录层数（步数）时，可以去掉上述框架中的
for 循环，比如 Dijkstra 算法中计算加权图的最短路径问题，详细探讨了 BFS
算法的扩展。</p>
<p>值得一提的是，有些很明显需要层序遍历技巧的二叉树的题目，也可以用递归遍历的方式去解决，而且技巧性会更强，非常考察你对前中后序的把控。</p>
<p>比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// root 视为第 0 层</span></span><br><span class="line">        traverse(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 前序位置，看看是否已经存储 depth 层的节点了</span></span><br><span class="line">        <span class="keyword">if</span> (res.size() &lt;= depth) &#123;</span><br><span class="line">            <span class="comment">// 第一次进入 depth 层</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序位置，在 depth 层添加 root 节点的值</span></span><br><span class="line">        res.get(depth).add(root.val);</span><br><span class="line">        traverse(root.left, depth + <span class="number">1</span>);</span><br><span class="line">        traverse(root.right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种思路从结果上说确实可以得到层序遍历结果，但其本质还是二叉树的前序遍历，或者说
DFS 的思路，而不是层序遍历，或者说 BFS
的思路。因为这个解法是依赖前序遍历自顶向下，自左向右的顺序特点得到了正确的结果。</p>
<p><strong>这个解法更像是从左到右的「列序遍历」，而不是自顶向下的「层序遍历」。</strong>所以对于计算最小距离的场景，这个解法完全等同于
DFS 算法，没有 BFS 算法的性能的优势。</p>
<h3 id="参考资料">参考资料</h3>
<ol type="1">
<li>labuladong 的算法小抄</li>
<li>牛客网</li>
<li>力扣网</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
        <category>算法框架</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法框架</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/article/43a71ae4.html</url>
    <content><![CDATA[<p>将多个字段组合成一个索引，这个索引就是联合索引。联合索引会按照<strong>「最左匹配」</strong>原则，进行索引匹配。</p>
<p>在<strong>联合索引的范围查询</strong>中，遇到 &gt;、&lt;
会停止匹配，范围查询的字段可以使用联合索引，但是范围查询字段后面的字段就无法使用了，而对于
&gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。</p>
<p>MySQL 5.6
引入了<strong>索引下推优化</strong>，可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>在建立联合索引时，<strong>要把区分度大的字段排在前面</strong>，效率更高。MySQL
有查询优化器，如果字段在表的数据行中占比超过界限（30%），会忽略索引，进行全表扫描。</p>
<p>索引的最大好处就是能够提高查询速度，但是创建索引和维护索引不仅耗时，索引还会占用空间，并且因为要动态维护索引而降低增删改的效率。</p>
<p>推荐对唯一字段、用于 WHERE、GROUP BY、ORDER BY
的字段建立索引，不推荐对数据量很小的表、存在大量重复数据的字段以及经常更新的字段建立索引。</p>
<span id="more"></span>
<h1 id="联合索引">联合索引</h1>
<h2 id="联合索引-1">联合索引</h2>
<p>将多个字段组合成一个索引，这个索引就是联合索引。</p>
<p><code>CREATE INDEX idx_product_no_name ON product(product_no, name);</code></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202308271529749.png"
alt="联合索引" />
<figcaption aria-hidden="true">联合索引</figcaption>
</figure>
<p>联合索引使用两个字段的值作为
key（黄色部分），按照<strong>最左匹配原则</strong>，进行索引匹配。如果不遵循「最左匹配原则」，联合索引会失效。</p>
<h2 id="最左匹配原则">最左匹配原则</h2>
<p>假设创建了一个联合索引 <strong>(a, b,
c)</strong>，联合索引生效的例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where a = 1;</span><br><span class="line">where a = 1 and b = 2 and c = 3;</span><br><span class="line">where a = 1 and b = 2;</span><br><span class="line">where b = 2 and a = 1 and c = 3;</span><br></pre></td></tr></table></figure>
<p>因为有查询优化器，所以 <strong>a 字段在 where
子句的顺序并不重要</strong>。</p>
<p><strong>联合索引失效</strong>的例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where b = 2;</span><br><span class="line">where c = 3;</span><br><span class="line">where b = 2 and c = 3;</span><br></pre></td></tr></table></figure>
<p>失效原因是，(a, b, c) 是联合索引，先按 a 排序，在 a 相同的情况再按 b
排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c
是全局无序，局部相对有序</strong>。如果没有遵循最左匹配原则，是无法利用索引的。</p>
<p>下面是联合索引(a, b)的 B+ Tree。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202308271719507.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>索引 a 全局有序 (1, 2, 2, 3, 4, 5, 6, 7, 8)，而索引 b 全局无序(12, 7,
8, 2, 3, 8, 10, 5, 2)。因此，直接执行 <code>where b = 2</code>
这种查询条件是无法利用联合索引的，利用索引的前提是，<strong>索引里的 key
是有序的</strong>。</p>
<p>只有在索引 a 相同的情况下，索引 b 才是有序的，比如 a = 2 时，b 的值是
(7, 8)，这时就是有序的，这个有序状态是局部的，因此，执行
<code>where a = 2 and b = 7</code> 是 a 和 b
字段能用到联合索引，也就是联合索引生效了。</p>
<h2 id="联合索引范围查询">联合索引范围查询</h2>
<p>联合索引有一些特殊情况，并<strong>不是查询过程使用了联合索引，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，可能存在部分字段用到联合索引，部分字段没有用到的情况。</p>
<p>这种特殊情况发生在范围查询。联合索引的最左匹配原则会从左到右匹配直到遇到「范围查询」就会停止匹配。即，<strong>范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p>
<p>范围查询有很多种，哪些范围查询会导致联合索引的最左匹配原则会停止匹配呢？</p>
<p><strong>联合索引的最左匹配原则，在遇到范围查询（如
&gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面字段无法用到联合索引。</strong></p>
<p><strong>对于 &gt;=、&lt;=、BETWEEN、like
前缀匹配的范围查询，并不会停止匹配。</strong></p>
<h2 id="索引下推">索引下推</h2>
<p>对于联合索引 (a, b)，在执行
<code>select * from table where a &gt; 1 and b = 2;</code> 语句时，只有
a 字段能用到索引，在联合索引的 B+ Tree 找到第一个满足条件的主键值(a =
2)后，还需要判断其他条件是否满足（看 b 是否等于
2），那是<strong>在联合索引里判断？还是回主键索引去判断？</strong></p>
<ul>
<li><p>在 MySQL 5.6 之前，只能从主键值（a =
2）开始一个个回表，到「主键索引」上找出数据行，再对比 b
字段值。</p></li>
<li><p>MySQL 5.6
引入了<strong>索引下推优化</strong>，<strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</p></li>
</ul>
<p>当你的查询语句的执行计划里，出现了 Extra 为
<code>Using index condition</code>，那么说明使用了索引下推的优化。</p>
<h2 id="索引区分度">索引区分度</h2>
<p>联合索引的字段顺序，对索引效率有很大的影响。越靠前的字段被用于索引过滤的概率越高，因此<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的
SQL 使用到</strong>。 <span class="math display">\[
区分度 = \frac{distinct(column)}{count(*)}
\]</span> <span class="math inline">\(distinct(column)\)</span>:
某个字段 column 不同值的个数，<span
class="math inline">\(count(*)\)</span>: 表的总行数。</p>
<p>比如，性别的区分度就很小，不适合做索引或排在联合索引列靠前的位置，而
UUID 就区分度就很大，就很适合。</p>
<p>MySQL
有一个查询优化器，如果发现某个值在表的数据行中的百分比（惯用界限
30%）很高时，会忽略索引，进行全表扫描。</p>
<h1 id="索引使用场景">索引使用场景</h1>
<h2 id="索引优缺点">索引优缺点</h2>
<h3 id="优点">优点</h3>
<p>提高查询速度</p>
<h3 id="缺点">缺点</h3>
<p>1、需要占用物理空间，数量越大，占用空间越大；</p>
<p>2、创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</p>
<p>3、会降低表的增删改的效率，因为每次增删改索引，B+
树为了维护索引有序性，都需要动态维护。</p>
<h2 id="推荐使用场景">推荐使用场景</h2>
<p>1、字段有唯一性限制的，比如订单号；</p>
<p>2、经常用于 <code>WHERE</code>
查询条件的字段，如果查询条件不是一个字段，可以建立联合索引。</p>
<p>3、经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code>
的字段，这样在查询的时候就不需要再做一次排序了，因为建立索引后在 B+ Tree
中的记录都是排序好的。</p>
<h2 id="不推荐场景">不推荐场景</h2>
<p>1、WHERE、GROUP BY、ORDER BY 用不到的字段；</p>
<p>2、字段存在大量重复数据，比如性别字段，MySQL
查询优化器会忽略该索引进行全表扫描；</p>
<p>3、表数据太少；</p>
<p>4、经常更新的字段，比如用户余额，因为要动态维护索引，影响数据库性能。</p>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找与排序</title>
    <url>/article/47bbfc8b.html</url>
    <content><![CDATA[<h3 id="相似解法题目多元组">相似解法题目多元组</h3>
<ul>
<li><strong>归并排序：</strong>&lt; BM20 数组中的逆序对，BM5 合并 k
个已排序的链表，BM12 单链表的排序 &gt;</li>
</ul>
<span id="more"></span>
<h3 id="bm20-数组中的逆序对">BM20 数组中的逆序对</h3>
<h4 id="描述">描述</h4>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将
P 对 1000000007 取模的结果输出。 即输出 P mod 1000000007。</p>
<p>题目保证输入的数组中没有的相同的数字。</p>
<h4 id="思路">思路</h4>
<p>归并排序</p>
<p>在归并排序过程中会将数组换分成最小为 1
个元素的子数组，然后依次比较子数组的每个元素的大小，依次取出较小的一个合并成大的子数组。</p>
<p>主要流程：取中间 -&gt; 左右划分 -&gt; 合并</p>
<p>我们可以用相同的方法划分，划分之后相邻一个元素的子数组可以根据大小统计逆序对。在不断往上合并的时候，因为已经排好序了，逆序对可以向上累计。</p>
<h4 id="f1归并排序">F1：归并排序</h4>
<h5 id="步骤">步骤</h5>
<ol type="1">
<li>划分阶段：将待划分区间从中点划分成两部分，两部分进入递归继续划分，直到子数组长度为
1。</li>
<li>排序阶段：
<ul>
<li>使用归并排序递归地处理子序列，同时统计逆序对，因为在归并排序中，我们会依次比较相邻两组子数组各个元素的大小，并累计遇到的逆序情况。</li>
<li>对排好序的两组，右边大于左边时，它大于了左边的所有子序列，基于这个性质，我们可以不用每次加
1 来统计，减少运算次数。</li>
</ul></li>
<li>合并阶段：将排好序的子序列合并，同时累加逆序对。</li>
</ol>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/DM_20230406161242_001.gif"
alt="归并排序统计逆序对" />
<figcaption aria-hidden="true">归并排序统计逆序对</figcaption>
</figure>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inversePairs</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line">    <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">return</span> mergeSort(<span class="number">0</span>, n - <span class="number">1</span>, array, help);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算逆序对的总数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] data, <span class="type">int</span>[] help)</span> &#123;</span><br><span class="line">    <span class="comment">// 停止划分</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 取中间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 左右划分合并</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> mergeSort(left, mid, data, help) + mergeSort(mid + <span class="number">1</span>, right, data, help);</span><br><span class="line">    <span class="comment">// 防止溢出</span></span><br><span class="line">    res %= mod;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>; <span class="comment">// 左、右指针</span></span><br><span class="line">    <span class="comment">// 将当前划分的数组全部填充到辅助数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt;= right; k++) &#123;</span><br><span class="line">        help[k] = data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt;= right; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123; <span class="comment">// 左指针到边界，后续只需右指针移动</span></span><br><span class="line">            data[k] = help[j]; <span class="comment">// 填充右边的值</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span>) &#123; <span class="comment">// 如果右指针到边界</span></span><br><span class="line">            data[k] = help[i]; <span class="comment">// 填充左边的值</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (help[i] &lt;= help[j]) &#123; <span class="comment">// 左指针的值 &lt;= 右指针的值</span></span><br><span class="line">            data[k] = help[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左右指针都没越界，左指针的值 &gt; 右指针的值</span></span><br><span class="line">            data[k] = help[j]; <span class="comment">// 填充右边的值</span></span><br><span class="line">            j++;</span><br><span class="line">            <span class="comment">// 符合逆序对的定义</span></span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度">时间复杂度</h5>
<p><span class="math inline">\(O(nlog_2n)\)</span></p>
<p>归并排序利用分治思想，树形递归每次二分，总共能分为 <span
class="math inline">\(log_2n\)</span>
层，每层合并都需要遍历数组所有元素，即 <span
class="math inline">\(O(n)\)</span>。</p>
<h5 id="空间复杂度">空间复杂度</h5>
<p><span class="math inline">\(O(n)\)</span></p>
<p>辅助数组 help 长度为 n 及递归栈最大深度不会超过 n。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>BinarySearchAndSort</category>
      </categories>
      <tags>
        <tag>NowCoder-TOP101</tag>
        <tag>Algorithm</tag>
        <tag>BinarySearchAndSort</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针巧解链表有环问题</title>
    <url>/article/434b00d3.html</url>
    <content><![CDATA[<p>链表有环问题可以使用<a
href="https://www.mrpersimmon.top/article/ba79aab0.html#%E5%8F%8C%E6%8C%87%E9%92%88">双指针</a>技巧轻松解决。</p>
<ul>
<li><p><strong>判断链表是否有环</strong>问题，可以通过设置<strong>快慢指针同向遍历链表</strong>，若相遇则有环。</p></li>
<li><p><strong>找环入口</strong>问题，也可以通过设置<strong>快慢指针同向遍历链表</strong>，寻找相遇点。不同的是，<strong>当两指针相遇后，快指针回到链表头节点，慢指针留在相遇节点，两者同速遍历，二次相遇点一定是环入口</strong>。</p></li>
</ul>
<p>下面两道题精选于<strong>牛客网面试必刷TOP101</strong>，相信我，十分简单，非常容易理解！</p>
<span id="more"></span>
<h3 id="bm6-判断链表中是否有环"><a
href="https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9">BM6
判断链表中是否有环</a></h3>
<h4 id="描述">描述</h4>
<p>判断给定的链表中是否有环。如果有环则返回 true，否则返回 false。</p>
<h4 id="思路">思路</h4>
<p>双指针</p>
<h5 id="线性与环形链表特点">线性与环形链表特点：</h5>
<ul>
<li><p>线性链表末尾一定有 null。</p></li>
<li><p><strong>环形链表的环一定在末尾，末尾没有 null
了。</strong></p></li>
</ul>
<h5 id="线性与环形链表结束条件">线性与环形链表结束条件：</h5>
<ul>
<li><p>线性链表的结束条件就是遍历到 null。</p></li>
<li><p><strong>环形链表会不断循环，需要借助双指针才能结束。</strong>同向访问的双指针，因为速度不同，只要有环，二者一定能相遇。</p></li>
</ul>
<h4 id="f1双指针">F1：双指针</h4>
<h5 id="步骤">步骤</h5>
<ol type="1">
<li>设置快慢两指针，初始都指向链表头；</li>
<li>遍历链表，快指针每次走两步，慢指针每次走一步；</li>
<li>如果快指针到了链表末尾，说明没有环，因为它每次走两步，所以要验证连续两步是否为
null；</li>
<li>如果链表有环，那快慢双指针会在环内循环，因为快指针每次走两步，因此快指针会在环内追到慢指针，二者相遇就代表有环。</li>
</ol>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/DM_20230405143207_001.gif"
alt="双指针判断链表是否有环" />
<figcaption aria-hidden="true">双指针判断链表是否有环</figcaption>
</figure>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 先判断链表为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 1. 设置快慢两指针，初始都指向链表头</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 2. 遍历链表</span></span><br><span class="line">    <span class="comment">// 3. 如果没环，fast 会先到链表尾</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 快指针移动两步</span></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 慢指针移动一步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="comment">// 相遇则有环</span></span><br><span class="line">        <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到末尾，则没有环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度">时间复杂度</h5>
<p><span class="math inline">\(O(M)\)</span></p>
<p>最坏情况下遍历链表 n 个节点。</p>
<h5 id="空间复杂度">空间复杂度</h5>
<p><span class="math inline">\(O(1)\)</span></p>
<p>仅使用了两个指针，没有额外辅助空间。</p>
<hr />
<h3 id="bm7-链表中环的入口点"><a
href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4">BM7
链表中环的入口点</a></h3>
<h4 id="描述-1">描述</h4>
<p>给一个长度为 n
链表，若其中包含环，请找出该链表的环的入口结点，否则，返回 null。</p>
<h5 id="分解任务">分解任务</h5>
<ol type="1">
<li>判断链表是否有环；</li>
<li>在有环的链表中找到环的入口。</li>
</ol>
<h4 id="思路-1">思路</h4>
<p>双指针</p>
<h5 id="如何找到环的入口">如何找到环的入口</h5>
<p>一个有环链表。</p>
<p>假设快指针在环中走了 <span class="math inline">\(n\)</span>
圈，慢指针走了 <span class="math inline">\(m\)</span> 圈，两者相遇。</p>
<p>链表头节点到环入口点距离为 <span
class="math inline">\(x\)</span>，环入口到相遇点距离为 <span
class="math inline">\(y\)</span>，相遇点到环入口点距离为 <span
class="math inline">\(z\)</span>。</p>
<p>快指针一共走了 <span class="math inline">\(x + n(y + z) + y\)</span>
步，慢指针一共走了 <span class="math inline">\(x + m(y + z) + y\)</span>
步。</p>
<p>快指针走的步数是慢指针的两倍，则 <span class="math display">\[
x + n(y + z) + y = 2(x + m(y + z) + y)
\]</span> 进一步推导， <span class="math display">\[
x+y=(n-2m)(y+z)
\]</span> 因为环的大小是 <span
class="math inline">\(y+z\)</span>，说明从链表头经过环入口到达相遇地方经过的距离等于整数倍环的大小。那么，我们从头开始遍历到相遇位置，和从相遇位置开始在环中遍历，会使用相同的步数，而双方最后都会经过入口到相遇位置这
<span class="math inline">\(y\)</span> 个节点，说明这 <span
class="math inline">\(y\)</span>
个节点它们就是重叠遍历的，那它们从入口位置就相遇了，这样就找到了入口节点。</p>
<h4 id="f1双指针-1">F1：双指针</h4>
<h5 id="步骤-1">步骤</h5>
<ol type="1">
<li>使用 BM6 方法判断链表是否有环，并找到相遇节点。</li>
<li>慢指针继续在相遇节点，快指针回到链表头，两个指针同步逐个元素开始遍历链表。</li>
<li>两者再次相遇的地方就是环的入口。</li>
</ol>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/DM_20230405143356_001.gif"
alt="双指针找环入口问题" />
<figcaption aria-hidden="true">双指针找环入口问题</figcaption>
</figure>
<h5 id="代码-1">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找链表中环的入口节点</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">entryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> hasCycle(pHead);</span><br><span class="line">    <span class="comment">// 没有环</span></span><br><span class="line">    <span class="keyword">if</span> (slow == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 有环</span></span><br><span class="line">    <span class="comment">// 快指针回到表头</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> pHead;</span><br><span class="line">    <span class="comment">// 再次相遇即是环入口</span></span><br><span class="line">    <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断有没有环</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 先判断链表为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 快慢双指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 如果没环，快指针会先到链表尾</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="comment">// 相遇则有环，返回相遇的节点</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到末尾说明没有换，返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-1">时间复杂度</h5>
<p><span class="math inline">\(O(n)\)</span></p>
<p>最坏情况下遍历链表两次</p>
<h5 id="空间复杂度-1">空间复杂度</h5>
<p><span class="math inline">\(O(1)\)</span></p>
<p>使用了常数个指针，没有额外辅助空间</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LinkedList</category>
      </categories>
      <tags>
        <tag>NowCoder-TOP101</tag>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针秒杀七道链表问题「详解版」</title>
    <url>/article/7cd9b3a4.html</url>
    <content><![CDATA[<p>本文使用双指针解决了如下算法问题：</p>
<p><a href="https://leetcode.cn/problems/linked-list-cycle/">力扣
141.环形链表</a></p>
<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">力扣
142.环形链表II</a></p>
<p><a
href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">力扣
160.相交链表</a></p>
<p><a
href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣
19.删除链表的倒数第 N 个节点</a></p>
<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">力扣
21.合并两个有序链表</a></p>
<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">力扣
23.合并 K 个升序链表</a></p>
<p><a href="https://leetcode.cn/problems/partition-list/">力扣
86.分割链表</a></p>
<p><a href="https://leetcode.cn/problems/partition-list/">力扣
876.链表的中间节点</a></p>
<p><a
href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指
Offer 22.链表中倒数第 k 个节点</a></p>
<p><a
href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指
Offer 25.合并两个排序的链表</a></p>
<p><a
href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指
Offer 52.两个链表的第一个公共节点</a></p>
<p><a
href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指
OfferII 021.删除链表的倒数第 n 个节点</a></p>
<p><a
href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指
OfferII 022.链表中环的入口节点</a></p>
<p><a
href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指
OfferII 023.两个链表的第一个重合节点</a></p>
<p><a
href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指
OfferII 078.合并排序链表</a></p>
<span id="more"></span>
<h3 id="力扣-21.合并两个有序链表"><a
href="https://leetcode.cn/problems/merge-two-sorted-lists/">力扣
21.合并两个有序链表</a></h3>
<h4 id="描述">描述</h4>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304100020246.jpg" alt="合并两个有序链表" style="zoom:40%;" /></p>
<h4 id="思路">思路</h4>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/1.gif" alt="双指针" style="zoom:50%;" /></p>
<h4 id="代码">代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    <span class="comment">// 虚拟头节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> list1, p2 = list2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 比较 p1 和 p2 两个指针</span></span><br><span class="line">        <span class="comment">// 将值比较小的节点接到 p 指针</span></span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt; p2.val) &#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 谁还剩余谁接到 p 指针</span></span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉虚拟头节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="技巧虚拟头节点">技巧：虚拟头节点</h4>
<p><strong>「虚拟头节点」，dummy 节点。</strong>如果不使用 dummy
虚拟节点，代码会复杂一些，需要额外处理指针 p 为空的情况。而有了 dummy
节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。</p>
<p><strong>什么时候需要用虚拟头节点？</strong></p>
<p><strong>当需要创造一条新链表的时候，可以使用虚拟头节点简化边界情况的处理。</strong></p>
<p>比如，把两条有序链表合并成一条新的有序链表，是创造一条新链表。把一条链表分解成两条链表，也是在创造新链表。这些情况都可以使用虚拟头节点简化边界情况的处理。</p>
<hr />
<h3 id="力扣-86.分割链表"><a
href="https://leetcode.cn/problems/partition-list/">力扣
86.分割链表</a></h3>
<h4 id="描述-1">描述</h4>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304100018935.jpg" alt="分割链表" style="zoom:40%;" /></p>
<h4 id="思路-1">思路</h4>
<p>在合并两个有序链表时，我们合二为一，而这道题需要我们将原链表一分为二。具体来说，我们可以把原链表分成两个小链表，一个链表中的元素大小都小于
x，另一个链表中的元素都大于等于
x，最后再把这两条链表接到一起，就得到了题目想要的结果。</p>
<h4 id="代码-1">代码</h4>
<p>注意虚拟头节点的运用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 存放小于 x 的链表的虚拟头节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 存放大于等于 x 的链表的虚拟头节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// p1, p2 指针负责生成结果链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> dummy1, p2 = dummy2;</span><br><span class="line">    <span class="comment">// p 负责遍历原链表，类似合并两个有序链表的逻辑</span></span><br><span class="line">    <span class="comment">// 这里是将一个链表分解成两个链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val &lt; x) &#123;</span><br><span class="line">            p1.next = p;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p2.next = p;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针前进</span></span><br><span class="line">        <span class="comment">// 需要断开原链表中的每个节点的 next 指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> p.next;</span><br><span class="line">        p.next = <span class="literal">null</span>;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连接两个链表</span></span><br><span class="line">    p1.next = dummy2.next;</span><br><span class="line">    <span class="keyword">return</span> dummy1.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="力扣-23.合并-k-个升序链表"><a
href="https://leetcode.cn/problems/merge-k-sorted-lists/">力扣 23.合并 K
个升序链表</a></h3>
<h4 id="描述-2">描述</h4>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304100026833.jpg" alt="合并 k 个升序链表" style="zoom:40%;" /></p>
<h4 id="思路-2">思路</h4>
<p>合并 k 个升序链表的逻辑类似合并两个链表，难点在于如何快速得到 k
个节点中的最小节点，接到结果链表上？</p>
<p>这里使用优先级队列（二叉堆），把链表节点放入一个最小堆，就可以每次获得
k 个节点中的最小节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 虚拟头节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="comment">// 优先级队列，最小堆。指定初始容量和比较器</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">        lists.length, (a, b) -&gt; (a.val - b.val));</span><br><span class="line">    <span class="comment">// 将 k 个链表的头节点加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>)</span><br><span class="line">            pq.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表上</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curNode</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        p.next = curNode;</span><br><span class="line">        <span class="keyword">if</span> (curNode.next != <span class="literal">null</span>)</span><br><span class="line">            pq.add(curNode.next);</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度是多少呢？</strong></p>
<p>优先级队列 pq 中的元素个数最多是 k，所以一次 poll 或者 add
方法的时间复杂度是 <span
class="math inline">\(O(logk)\)</span>；所有的链表节点都会被加入和弹出
pq，<strong>所以算法整体的时间复杂度是 <span
class="math inline">\(O(Nlogk)\)</span>，其中 k 是链表的条数，N
是这些链表的节点总数。</strong></p>
<hr />
<h3 id="力扣-19.删除链表的倒数第-n-个节点"><a
href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣
19.删除链表的倒数第 N 个节点</a></h3>
<h4 id="快指针先行-k-步">快指针先行 k 步</h4>
<p>链表不能逆序遍历，那么如何寻找从后往前数的第 k 个节点呢？</p>
<p>可能有这样一种想法，假设链表有 n 个节点，倒数第 k 个节点就是正数第 n
- k + 1 个节点，直接遍历不就可以了吗？</p>
<p>但是，算法题一般只给 ListNode
头节点代表一条单链表，不能直接得出这条链表的长度
n，而需要先遍历一遍链表算出 n 的值，然后再遍历链表计算第 n - k + 1
个节点。</p>
<p>也就是说，这种解法需要遍历两次链表才能得出倒数第 k 个节点。</p>
<p>那么，<strong>如何只遍历一次链表，就算出倒数第 k
个节点？</strong>这也是面试官希望给出的解法。</p>
<p>假设 k = 2，思路如下：</p>
<p>首先，我们先让一个指针 p1 指向链表的头节点 head，然后走 k 步：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304101006464.jpg" alt="p1 指针先走 k 步" style="zoom:40%;" /></p>
<p>现在的 p1，只要再走 n - k 步，就能走到链表末尾的空指针。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Framework</category>
        <category>Algorithn</category>
        <category>LinkedList</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
        <tag>AlgorithmFramework</tag>
        <tag>TwoPointers</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/article/850f2080.html</url>
    <content><![CDATA[<h3 id="相似解法题目多元组">相似解法题目多元组</h3>
<ul>
<li><strong>哈希表：</strong>&lt;BM50 两数之和，BM54 三数之和&gt;</li>
</ul>
<span id="more"></span>
<h3 id="bm50-两数之和">BM50 两数之和</h3>
<h4 id="描述">描述</h4>
<p>给出一个整型数组 numbers 和一个目标值
target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。</p>
<p>注：<strong>返回</strong>的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到。</p>
<h4 id="思路">思路</h4>
<p><strong>哈希表</strong></p>
<p>如果数组中出现的一个数 a，目标值减去 a
的值已经出现过了，那么这就是我们要找的一对元组。</p>
<p>快速找到已经出现过的某个值，可以使用哈希表快速检验某个元素是否出现过的功能。</p>
<h4 id="f1哈希表">F1：哈希表</h4>
<h5 id="步骤">步骤</h5>
<ol type="1">
<li>构建一个哈希表，key 为遍历数组过程中出现过的值，value
为其相应的下标，因为最终要返回的是下标。</li>
<li>遍历数组每个元素，如果目标值减去该元素的结果在哈希表中存在，说明我们先前遍历的时候它出现过，根据记录的下标，就可以得到结果。</li>
<li>如果相减后的结果没有在哈希表中，说明先前遍历的元素中没有它对应的另一个值，那我们将当前数组元素加入哈希表中，等待后续它匹配的那个值出现即可。</li>
<li>需要注意最后的结果是下标值加 1。</li>
</ol>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum (<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 1. 创建哈希表,两元组分别表示值、下标</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 2. 遍历数组，在哈希表中查找 target - numbers[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> target - numbers[i];</span><br><span class="line">        <span class="comment">// 3. 若是没找到，将当前数组元素和下标计入哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(tmp)) &#123;</span><br><span class="line">            map.put(numbers[i], i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4. 否则返回两个下标 +1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(tmp) + <span class="number">1</span>, i + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度">时间复杂度</h5>
<p><span class="math inline">\(O(n)\)</span></p>
<p>仅仅遍历数组一次，每次查询哈希表都是 <span
class="math inline">\(O(1)\)</span></p>
<h5 id="空间复杂度">空间复杂度</h5>
<p><span class="math inline">\(O(n)\)</span></p>
<p>最坏情况下，遍历到数组结尾才找到，其他都加入哈希表，因此哈希表最长为
n - 1 的长度。</p>
<hr />
<h3 id="bm54-三数之和">BM54 三数之和</h3>
<h4 id="描述-1">描述</h4>
<p>给出一个有 n 个元素的数组 S，S 中是否有元素 a, b, c
满足a+b+c=0？找出数组 S 中所有满足条件的三元组。</p>
<p>注意：</p>
<ol type="1">
<li>三元组（a、b、c）中的元素必须按非降序排列。（即 a≤b≤c）</li>
<li>解集中不能包含重复的三元组。</li>
</ol>
<p>例如，给定的数组 S = {-10 0 10 20 -10 -40}，解集为 [(-10, -10, 20),
(-10, 0, 10)]</p>
<h4 id="思路-1">思路</h4>
<p><strong>哈希表、双指针</strong></p>
<p>直接找三个数字之和为某个数，太过麻烦。可以进行拆分：<strong>如果找到了某个数
a，要找到与之对应的另外两个数，三数之和为 0，那只要找到另外两个数之和为
-a 即可。</strong></p>
<p>因为三元组内部必须有序，可以优先对原数组排序，每次取一个最小的数为
a，只需要在后续数组中找到两个和为 -a
就可以了。可以使用双指针缩小区间，因为太后面的数字太大了，就不可能为
-a，可以舍弃。</p>
<h4 id="f1哈希表双指针">F1：哈希表+双指针</h4>
<h5 id="步骤-1">步骤</h5>
<ol type="1">
<li>排除边界特殊情况；</li>
<li>要求三元组内部必须有序，因此对原数组使用 sort 函数排序；</li>
<li>得到有序数组后，遍历该数组，对于每个遍历到元素，假设它是三元组中最小的一个，那么另外两个一定在后面。</li>
<li>需要三个数相加为
0，则另外两个数相加应该为上述第一个数的相反数，我们可以利用双指针在剩余的子数组中找有没有这样的数对。<strong>双指针指向剩余子数组的首尾，如果二者相加为目标值，那么就可以记录，而且二者中间数字相加可能还会有。</strong></li>
<li>如果二者相加大于目标值，说明右指针太大了，那么就将其左移缩小，相反如果二者相加小于目标值，说明左指针太小了，将其右移扩大，直到两指针相遇，剩余子数组找完了。</li>
</ol>
<p>注意：对于三个数字都要判断是否相邻有重复的情况，要去重。</p>
<h5 id="代码-1">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] num)</span> &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num.length;</span><br><span class="line">        <span class="comment">// 1. 边界：不够三元组</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 对原数组排序</span></span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        <span class="comment">// 3. 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; num[i] == num[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 剩余子数组首尾双指针</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当前目标值：当前值的相反数（-a）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -num[i];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="comment">// 4. 双指针指向的两值相加为 target，则可以与 num[i] 组成 0</span></span><br><span class="line">                <span class="keyword">if</span> (num[left] + num[right] == target) &#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    tmp.add(num[i]);</span><br><span class="line">                    tmp.add(num[left]);</span><br><span class="line">                    tmp.add(num[right]);</span><br><span class="line">                    ans.add(tmp);</span><br><span class="line">                    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right &amp;&amp; num[left] == num[left + <span class="number">1</span>])</span><br><span class="line">                        left++;<span class="comment">// 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right - <span class="number">1</span> &gt; left &amp;&amp; num[right] == num[right - <span class="number">1</span>])</span><br><span class="line">                        right--; <span class="comment">// 去重</span></span><br><span class="line">                    <span class="comment">// 双指针向中间收缩</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 5.1 双指针的值之和大于目标值，右指针值太大了，向左移动</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (num[left] + num[right] &gt; target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 5.2 双指针的值之和小于目标值，左指针值太小了，向右移动</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-1">时间复杂度</h5>
<p><span class="math inline">\(O(n^2)\)</span></p>
<p>排序的复杂度为 <span
class="math inline">\(O(nlog_2n)\)</span>，查找三元组的复杂度为 <span
class="math inline">\(O(n^2)\)</span></p>
<h5 id="空间复杂度-1">空间复杂度</h5>
<p><span class="math inline">\(O(1)\)</span></p>
<p>ans 属于必要空间，不属于额外空间，无其他辅助空间。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>NowCoder-TOP101</tag>
        <tag>Algorithm</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/article/fc81fbfd.html</url>
    <content><![CDATA[<h3 id="相似解法题目多元组">相似解法题目多元组</h3>
<ul>
<li><strong>模拟：</strong>&lt;BM86 大数加法，BM11 链表相加(二)&gt;</li>
</ul>
<span id="more"></span>
<h3 id="bm86-大数相加">BM86 大数相加</h3>
<h4 id="描述">描述</h4>
<p>以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。</p>
<p>例如，输入 "1", "99"，返回 "100"。</p>
<h4 id="思路">思路</h4>
<p>模拟</p>
<p>大整数相加，可以按照整数相加的方式，从个位开始，逐渐向上累加。在字符串中就是从两个字符串的末尾开始相加。</p>
<h4 id="f1模拟法">F1：模拟法</h4>
<h5 id="步骤">步骤</h5>
<p>做法与 <strong>BM11
链表相加（二）</strong>几乎一致。不同的地方，一个是字符串可以直接从后向前遍历；二是在于最后的进位需要在返回前进行判断，再决定是否给字符串添加进位'1'。</p>
<ol type="1">
<li>若是其中一个字符串为空，直接返回另一个，不用加了。</li>
<li>设置两个用于遍历各自字符串的下标 i，j 以及用于遍历辅助字符数组的下标
p，取最大的字符串长度作为辅助字符数组的长度，设置进位 carry = 0。</li>
<li>从后开始遍历两个字符串，直到两个下标都为 -1。每次取出非 -1
的下标的字符转换成数字，如果是 -1 就设置为 0，将两个转换好的数字与carry
相加，然后查看是否进位，将进位后的结果（对 10
取模）放入对应辅助字符数组内，并继续向前遍历。</li>
<li>遍历结束后，将辅助字符数组转换成字符串，如果存在进位，则直接在字符串前增加一个字符
'1'。</li>
</ol>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">solve</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 其中一个为空，返回另一个</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">if</span> (t.length() &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">// 2. 设置辅助参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 设置进位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; <span class="comment">// s 下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t.length() - <span class="number">1</span>; <span class="comment">// t 下标</span></span><br><span class="line">    <span class="type">char</span>[] help = <span class="keyword">new</span> <span class="title class_">char</span>[Math.max(i, j) + <span class="number">1</span>]; <span class="comment">// 取最大的字符串长度作为辅助字符数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> help.length - <span class="number">1</span>; <span class="comment">// 辅助数组下标</span></span><br><span class="line">    <span class="comment">// 3. 只要某个字符串还有字符</span></span><br><span class="line">    <span class="keyword">while</span> (i != -<span class="number">1</span> || j != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 下标不为 -1，取出字符并转换成数字，否则为 0。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i == -<span class="number">1</span> ? <span class="number">0</span> : s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> j == -<span class="number">1</span> ? <span class="number">0</span> : t.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 相加</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b + carry;</span><br><span class="line">        <span class="comment">// 获取进位</span></span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 获取放入辅助数组的值，取模去掉十位</span></span><br><span class="line">        sum %= <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 将数值转换成字符</span></span><br><span class="line">        help[p] = (<span class="type">char</span>)(sum + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        p--;</span><br><span class="line">        <span class="comment">// 下标不为 -1，向前移动</span></span><br><span class="line">        <span class="keyword">if</span> (i != -<span class="number">1</span>)</span><br><span class="line">            i--;</span><br><span class="line">        <span class="keyword">if</span> (j != -<span class="number">1</span>)</span><br><span class="line">            j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 将辅助字符数组转换成字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> String.valueOf(help);</span><br><span class="line">    <span class="comment">// 如果进位还存在，在字符串前增加一个字符 &#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">        output = <span class="string">&#x27;1&#x27;</span> + output;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度">时间复杂度</h5>
<p><span class="math inline">\(O(max(m,n))\)</span></p>
<p>其中 m 与 n 分别为两个字符串的长度。</p>
<h5 id="空间复杂度">空间复杂度</h5>
<p><span class="math inline">\(O(max(m,n))\)</span></p>
<p>其中 m 与 n 分别为两个字符串的长度，用于辅助字符数组。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Simulation</category>
      </categories>
      <tags>
        <tag>NowCoder-TOP101</tag>
        <tag>Algorithm</tag>
        <tag>String</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>基于算法(4th)单词查找树的改进</title>
    <url>/article/84520ef4.html</url>
    <content><![CDATA[<p>Trie
树，又名字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作。</p>
<p>本文在《算法(4th)》的单词查找树的基础上，参考《labuladong
的算法小抄》与《程序员代码指南》对其进行改进。</p>
<span id="more"></span>
<blockquote>
<p><strong>注意：</strong></p>
<p>由于 Trie 树原理，我们要求 TrieMap<V> 的键必须是字符串类型，值的类型
V 可以随意。</p>
</blockquote>
<h2 id="trie-树原理">Trie 树原理</h2>
<p>Trie 树本质上就是一棵从二叉树衍生出来的多叉树。</p>
<h3 id="二叉树">二叉树</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本二叉树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304132319172.jpeg" alt="二叉树结构" style="zoom:50%;" /></p>
<h3 id="多叉树">多叉树</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本多叉树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 children 数组中存储指向孩子节点的指针。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304132321828.jpeg" alt="多叉树结构" style="zoom:50%;" /></p>
<h3 id="前缀树">前缀树</h3>
<h4 id="trienode-代码">TrieNode 代码</h4>
<p>TrieMap 中的树节点 TrieNode 的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Trie 树节点的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">val</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 键存储对应的值</span></span><br><span class="line">    <span class="type">int</span> pass; <span class="comment">// 表示有多少个单词共用这个节点</span></span><br><span class="line">    <span class="type">int</span> end; <span class="comment">// 表示有多少个单词以这个节点结尾</span></span><br><span class="line">    HashMap&lt;Character, TrieNode&lt;V&gt;&gt; children; <span class="comment">// key 代表该节点一条字符路径，value 表示字符路径指向的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>HashMap&lt;Character, TrieNode&lt;V&gt;&gt; children</code>，也可以使用数组<code>TrieNode&lt;V&gt;[] children</code>来替代，比如长度为
256 的数组或者长度为 26 的数组，索引代表字符的 ASCII 码值。</p>
</blockquote>
<h4 id="trie-树结构图">Trie 树结构图</h4>
<p><a
href="https://www.cs.usfca.edu/~galles/visualization/Trie.html">Trie
树动画网站</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304132330865.jpeg" alt="Trie 树的结构" style="zoom:50%;" /></p>
<p>一个节点有 256
个子节点指针，但大多数时候都是空的，可以省略掉不画，所以一般看到的 Trie
树是这个样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304141101427.jpeg" alt="Trie 树" style="zoom:50%;" /></p>
<p>这是在 <code>TrieMap&lt;Integer&gt;</code>
中插入一些键值对后的样子，白色节点代表 val 字段为空，橙色节点代表 val
字段非空。</p>
<blockquote>
<p><strong>TrieNode 节点本身只存储 val
字段，并没有一个字段来存储字符，字符通过哈希表的 key
来确定。</strong></p>
<p><strong>形象理解就是，Trie
树用「树枝」存储字符串（键），用「节点」存储字符串（键）对应的数据（值）。</strong></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304141110361.jpeg" alt="树枝与节点" style="zoom:50%;" /></p>
<p>Trie
树叫前缀树的原因是，因为其中的字符串共享前缀，相同前缀的字符串集中在
Trie 树中的一个子树上，给字符串的处理带来很大的便利。</p>
<h2 id="triemaptrieset-api-及实现">TrieMap/TrieSet API 及实现</h2>
<h3 id="triemap">TrieMap</h3>
<p>假设 TrieMap 中已经存储了如下键值对：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304141117593.jpeg" alt="TrieMap 已经存储的键值对" style="zoom:50%;" /></p>
<h4 id="triemap-api">TrieMap API</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/***** 增、改 ******/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 中添加 key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 删 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键 key 以及对应的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 查 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索 key 对应的值，不存在则返回 null</span></span><br><span class="line">    <span class="comment">// get(&quot;the&quot;) -&gt; 4</span></span><br><span class="line">    <span class="comment">// get(&quot;tha&quot;) -&gt; null</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 key 是否存在在 Map 中</span></span><br><span class="line">    <span class="comment">// containsKey(&quot;tea&quot;) -&gt; false</span></span><br><span class="line">    <span class="comment">// containsKey(&quot;team&quot;) -&gt; true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 的所有键中搜索 query 的最短前缀</span></span><br><span class="line">    <span class="comment">// shortestPrefixOf(&quot;themxyz&quot;) -&gt; &quot;the&quot;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Map 的所有键中搜索 query 的最长前缀</span></span><br><span class="line">    <span class="comment">// longestPrefixOf(&quot;themxyz&quot;) -&gt; &quot;them&quot;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索所有前缀为 prefix 的键</span></span><br><span class="line">    <span class="comment">// keysWithPrefix(&quot;th&quot;) -&gt; [&quot;that&quot;, &quot;the&quot;, &quot;them&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在前缀为 prefix 的键</span></span><br><span class="line">    <span class="comment">// hasKeyWithPrefix(&quot;tha&quot;) -&gt; true</span></span><br><span class="line">    <span class="comment">// hasKeyWithPrefix(&quot;apple&quot;) -&gt; false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，搜索所有匹配的键</span></span><br><span class="line">    <span class="comment">// keysWithPattern(&quot;t.a.&quot;) -&gt; [&quot;team&quot;, &quot;that&quot;]</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通配符 . 匹配任意字符，判断是否存在匹配的键</span></span><br><span class="line">    <span class="comment">// hasKeyWithPattern(&quot;.ip&quot;) -&gt; true</span></span><br><span class="line">    <span class="comment">// hasKeyWithPattern(&quot;.i&quot;) -&gt; false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 Map 中键值对的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询 TrieMap 中指定 key 出现的次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsEqualTo</span><span class="params">(String key)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  查询 TrieMap 中以 prefix 为前缀的 key 的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsStartingWith</span><span class="params">(String prefix)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TrieSet 的 API 与 TrieMap API 几乎一致。</p>
<h4 id="实现上述-api-函数">实现上述 API 函数</h4>
<h5 id="trienodesizeroot-根节点">TrieNode、size、root 根节点</h5>
<p>TrieMap 类中一定需要记录 Trie 的根节点 root，以及 Trie
树中的所有节点数量用于实现 size() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前存在 Map 中的键值对个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">val</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> pass;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        HashMap&lt;Character, TrieNode&lt;V&gt;&gt; children;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            val = <span class="literal">null</span>;</span><br><span class="line">            pass = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trie 树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; root = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieMap</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 其他 API 实现</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 Map 中键值对的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="工具函数-getnode">工具函数 getNode</h5>
<p>实现一个工具函数 getNode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 node 节点搜索 key，如果存在返回「对应节点」，否则返回 null</span></span><br><span class="line"><span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">getNode</span><span class="params">(TrieNode&lt;V&gt; node, String key)</span> &#123;</span><br><span class="line">    TrieNode&lt;V&gt; p = node; <span class="comment">// 从节点 node 开始搜索 key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 方法 1：</span></span><br><span class="line"><span class="comment">//            char path = key.charAt(i); // 确定路径</span></span><br><span class="line"><span class="comment">//            if (!p.children.containsKey(path))&#123; // 路径下方节点不存在</span></span><br><span class="line"><span class="comment">//                // 无法向下搜索</span></span><br><span class="line"><span class="comment">//                return null;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            p = p.children.get(path);// 向下搜索</span></span><br><span class="line">        <span class="comment">// 方法 2：</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 无法向下搜索</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> key.charAt(i); <span class="comment">// 确定路径</span></span><br><span class="line">        p = p.children.get(path);<span class="comment">// 向下搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304142006001.jpeg" alt="getNode" style="zoom:50%;" /></p>
<h5 id="containskey-和-get">containsKey 和 get</h5>
<p>有了这个 getNode 函数，就能实现 containsKey 方法和 get 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 搜索 key 对应的值，不存在则返回 null</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 root 开始搜索 key</span></span><br><span class="line">    TrieNode&lt;V&gt; x = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span> || x.val == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// x 为空或 x 的 val 字段为空都说明 key 没有对应的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 key 是否存在在 Map 中</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>就算 getNode(key) 的返回值 x 非空，也只能说明字符串 key
是一个「前缀」；除非 x.val 同时非空，才能判断键 key 存在。</strong></p>
<h5 id="haskeywithprefix">hasKeyWithPrefix</h5>
<p>但是，这个特性恰好能够帮我们实现 <code>hasKeyWithPrefix</code>
方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是和否存在前缀为 prefix 的键</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">    <span class="comment">// 只要能找到 prefix 对应的节点，就是存在前缀</span></span><br><span class="line">    <span class="keyword">return</span> getNode(root, prefix) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="shortestprefixof">shortestPrefixOf</h5>
<p>类似 getNode 方法的逻辑，我们可以实现 shortestPrefixOf
方法，只要在第一次遇到存有 val 的节点的时候返回即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 Map 的所有键中搜索 query 的最短前缀</span></span><br><span class="line"><span class="comment">// shortestPrefixOf(&quot;themxyz&quot;) -&gt; &quot;the&quot;</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">    TrieNode&lt;V&gt; p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; query.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123; <span class="comment">// 无法向下搜索</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val != <span class="literal">null</span>) &#123; <span class="comment">// 找到一个键是 query 的前缀</span></span><br><span class="line">            <span class="keyword">return</span> query.substring(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> query.charAt(i);</span><br><span class="line">        p = p.children.get(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; p.val != <span class="literal">null</span>) &#123; <span class="comment">// 如果 query 本身就是一个键</span></span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，for 循环结束之后需要额外检查一下。因为 Trie 树中
「树枝」存储字符串，「节点」存储字符串对应的值，for
循环相当于只遍历了「树枝」，但漏掉了最后一个「节点」，即 query 本身就是
TrieMap 中的一个键的情况。</p>
<h5 id="longestprefixof">longestPrefixOf</h5>
<p>类似地，可以实现 longestPrefixOf 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 Map 的所有键中搜索 query 的最长前缀</span></span><br><span class="line"><span class="comment">// longestPrefixOf(&quot;themxyz&quot;) -&gt; &quot;them&quot;</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录前缀的最大长度</span></span><br><span class="line">    TrieNode&lt;V&gt; p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; query.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 无法向下搜索</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            maxLen = i; <span class="comment">// 找到一个键是 query 的前缀，更新前缀的最大长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向下搜索</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> query.charAt(i); </span><br><span class="line">        p = p.children.get(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; p.val != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> query; <span class="comment">// 如果 query 本身就是一个键，那么这就是最长前缀</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> query.substring(<span class="number">0</span>, maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次遇到 p.val 非空的时候说明找到一个键，但是不要急着返回，而是更新
maxLen 变量，记录最长前缀的长度。</p>
<p>同样的，在 for 循环结束时要特殊判断一下，处理 query
本身就是键的情况。</p>
<h5 id="keyswithprefix">keysWithPrefix</h5>
<p><code>keysWithPrefix</code> 方法，用于得到所有前缀为
<code>prefix</code> 的键。</p>
<p>具体的方法是，先利用 <code>getNode</code> 函数在 Trie 树中找到
<code>prefix</code> 对应的节点
<code>p</code>，然后使用多叉树的遍历算法，遍历以 <code>p</code>
为根的这棵 Trie 树，找到所有键值对。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304171551167.jpeg" alt="keysWithPrefix 实现流程" style="zoom:50%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 搜索所有前缀为 prefix 的键</span></span><br><span class="line"><span class="comment">// keysWithPrefix(&quot;th&quot;) -&gt; [&quot;that&quot;, &quot;the&quot;, &quot;them&quot;]</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 找到匹配 prefix 在 Trie 树中的那个节点</span></span><br><span class="line">    TrieNode&lt;V&gt; p = getNode(root, prefix);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) <span class="comment">// 不存在 prefix</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 回溯遍历以 x 为根的这棵 Trie 树</span></span><br><span class="line">    traverse(p, <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(prefix), res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历以 node 节点为根的 Trie 树，找到所有「键」</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, StringBuffer path, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 到达 Trie 树底部叶子节点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到一个 key，添加到结果列表中</span></span><br><span class="line">        res.add(path.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回溯算法遍历框架</span></span><br><span class="line">    <span class="comment">// c 选择，node.children.keySet() 选择列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : node.children.keySet()) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.append(c);</span><br><span class="line">        traverse(node.children.get(c), path, res);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>traverse 函数使用的是回溯算法框架，其<strong>核心就是 for
循环里的递归，在递归调用前「做选择」，在递归后「撤销选择」。</strong></p>
<p>回溯算法与 DFS
算法非常类似，两者的差别是：<strong>回溯算法是在遍历「树枝」，DFS
算法是在遍历「节点」。</strong>由于 Trie 树将字符存储在
「树枝」上，traverse
函数是在遍历树枝上的字符，所以采用的是回溯算法框架。</p>
<h5 id="keyswithpattern">keysWithPattern</h5>
<p><code>keysWithPattern</code>
方法，使用通配符来匹配多个键，其关键就在于通配符<code>.</code>可以匹配字符。</p>
<p>在代码实现上，用 path
变量记录匹配键的路径，遇到通配符时使用类似回溯算法的框架就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通配符 . 匹配任意字符，搜索所有匹配的键</span></span><br><span class="line"><span class="comment">// keysWithPattern(&quot;t.a.&quot;) -&gt; [&quot;team&quot;, &quot;that&quot;]</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    traverse(root, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), pattern, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, StringBuilder path, String pattern, <span class="type">int</span> i, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 树枝不存在，即匹配失败</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == pattern.length()) &#123;</span><br><span class="line">        <span class="comment">// pattern 匹配完成</span></span><br><span class="line">        <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果这个节点存储着 val，则找到一个匹配的键</span></span><br><span class="line">            res.add(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// pattern[i] 是通配符，可以变化成任意字符</span></span><br><span class="line">        <span class="comment">// 多叉树（回溯算法）遍历框架</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> j : node.children.keySet()) &#123;</span><br><span class="line">            path.append(j); <span class="comment">// 做选择</span></span><br><span class="line">            traverse(node.children.get(j), path, pattern, i + <span class="number">1</span>, res);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>); <span class="comment">// 撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// pattern[i] 是普通字符 c</span></span><br><span class="line">        path.append(c); <span class="comment">// 做选择</span></span><br><span class="line">        traverse(node.children.get(c), path, pattern, i + <span class="number">1</span>, res);</span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>); <span class="comment">// 撤销选择</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 GIF 描述匹配 "t.a." 的过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304172245089.gif" alt="匹配 &quot;t.a.&quot; 的过程" style="zoom:50%;" /></p>
<p>可以看到，keysWithPattern 和 keysWithPrefix 的实现是有些类似的。</p>
<blockquote>
<p>如果使用 children
是使用数组存储的，那么它们返回的结果列表一定是符合「字典序」的。</p>
<p>因为每一个节点的 children 数组都是从左到右进行遍历，即按照 ASCII
码从小到大的顺序递归遍历，得到的结果自然是符合字典序的。</p>
</blockquote>
<h5 id="haskeywithpattern">hasKeyWithPattern</h5>
<p>hasKeyWithPattern 判断是否存在匹配的键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通配符 . 匹配任意字符，判断是否存在匹配的键</span></span><br><span class="line"><span class="comment">// hasKeyWithPattern(&quot;.ip&quot;) -&gt; true</span></span><br><span class="line"><span class="comment">// hasKeyWithPattern(&quot;.i&quot;) -&gt; false</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 root 节点开始匹配 pattern[0..]</span></span><br><span class="line">    <span class="keyword">return</span> traverse(root, pattern, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 node 节点开始匹配 pattern[i..]，返回是否成功匹配</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, String pattern, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 树枝不存在，即匹配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == pattern.length()) &#123;</span><br><span class="line">        <span class="comment">// 模式串走到头了，看看匹配到的是否是一个键</span></span><br><span class="line">        <span class="keyword">return</span> node.val != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">    <span class="comment">// 没有遇到通配符</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 node.children.get(c) 节点开始匹配 pattern[i+1..]</span></span><br><span class="line">        <span class="keyword">return</span> traverse(node.children.get(c), pattern, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遇到通配符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> j : node.children.keySet()) &#123;</span><br><span class="line">        <span class="comment">// pattern[j] 可以变化成任意字符，尝试所有可能，只要遇到一个匹配成功就返回</span></span><br><span class="line">        <span class="keyword">if</span> (traverse(node.children.get(j), pattern, i + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 都没有匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，TrieMap 的所有和前缀相关的方法都实现完了。</p>
<p>现在还需要实现 put 和 remove 以及 countWordsEqualTo 和
countWordsStartingWith 方法。</p>
<h5 id="put">put</h5>
<p>put 方法向 map 中添加或修改键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向 map 中添加或修改键值对</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    TrieNode&lt;V&gt; node = root; <span class="comment">// 从根节点开始</span></span><br><span class="line">    node.pass++; <span class="comment">// 根节点 pass++</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123; <span class="comment">// 遍历字符串</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> key.charAt(i); <span class="comment">// 确定字符路径</span></span><br><span class="line">        <span class="keyword">if</span> (!node.children.containsKey(path)) &#123; <span class="comment">// 如果路径下方节点不存在</span></span><br><span class="line">            node.children.put(path, <span class="keyword">new</span> <span class="title class_">TrieNode</span>&lt;&gt;()); <span class="comment">// 新建节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children.get(path); <span class="comment">// 节点存在，node 向下移动</span></span><br><span class="line">        node.pass++; <span class="comment">// 经过的节点 pass++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key 的路径已插入完成，将值 val 存入节点</span></span><br><span class="line">    node.val = val;</span><br><span class="line">    node.end++; <span class="comment">// 最后的节点 end++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Trie 树中的 <code>key</code>
就是「树枝」，值就是「节点」，所以插入的逻辑就是沿路新建「树枝」，把
<code>key</code> 的整条「树枝」构建出来后，在树枝末端的「节点」中存储
<code>val</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304222235313.gif" alt="put 方法" style="zoom:50%;" /></p>
<h5 id="remove">remove</h5>
<p>remove 方法在 map 中删除 key。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 map 中删除 key</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!containsKey(key)) &#123; <span class="comment">// 判断 key 是否在 Trie 树中</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size--; <span class="comment">// 键值对数量 - 1</span></span><br><span class="line">    TrieNode&lt;V&gt; node = root; <span class="comment">// 从根节点开始</span></span><br><span class="line">    node.pass--; <span class="comment">// 根节点 pass - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> key.charAt(i); <span class="comment">// 确定字符路径</span></span><br><span class="line">        <span class="keyword">if</span> (--node.children.get(path).pass == <span class="number">0</span>) &#123; <span class="comment">// 如果路径下面的节点 pass - 1 == 0</span></span><br><span class="line">            node.children.remove(path); <span class="comment">// 移除该节点，后续节点会被 gc 掉</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children.get(path); <span class="comment">// node 向下移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    node.end--; <span class="comment">// 最终节点 end - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想删除键 <code>team</code>，那么需要删除 <code>eam</code>
这条树枝，才符合逻辑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304222242831.jpeg" alt="remove 方法" style="zoom:50%;" /></p>
<p>删多了不行，删少了也不行，否则前面实现的
<code>hasKeyWithPrefix</code> 就会出错。</p>
<p><strong>如何判断一个节点是否需要被删除呢？节点的 pass 值为 0
的时候，就需要被移除，后续的节点会被 GC 掉。</strong></p>
<h5 id="countwordsequalto">countWordsEqualTo</h5>
<p>countWordsEqualTo 查询 TrieMap 中指定 key 出现的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询 TrieMap 中指定 key 出现的次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsEqualTo</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TrieNode&lt;V&gt; node = root; <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123; <span class="comment">// 遍历字符串</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> key.charAt(i); <span class="comment">// 确定字符路径</span></span><br><span class="line">        <span class="keyword">if</span> (!node.children.containsKey(path)) &#123; <span class="comment">// 如果路径下方不存在节点，返回 0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children.get(path); <span class="comment">// 节点存在，向下移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.end; <span class="comment">// 返回 end 值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="countwordsstartingwith">countWordsStartingWith</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询 TrieMap 中以 prefix 为前缀的 key 的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsStartingWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TrieNode&lt;V&gt; node = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!node.children.containsKey(path)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children.get(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.pass; <span class="comment">// 返回 pass 值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>countWordsStartingWith</code> 方法与
<code>countWordsEqualTo</code>
方法的主要不同在于，<strong>抵达最终节点时，一个返回 <code>end</code>
值，一个返回 <code>pass</code> 值。</strong></p>
<p>到这里，<code>TrieMap</code> 的所有 API 就都实现完毕了。</p>
<h3 id="trieset">TrieSet</h3>
<p>只要对 <code>TrieMap</code> 做简单的封装，就可以实现
<code>TrieSet</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieSet</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 底层用一个 TrieMap，键就是 TrieSet，值仅仅起到占位的作用</span></span><br><span class="line">    <span class="comment">// 值的类型可以随便设置，参考 Java 标准库设置为 Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrieMap&lt;Object&gt; map = <span class="keyword">new</span> <span class="title class_">TrieMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        map.put(key, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        map.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.shortestPrefixOf(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.longestPrefixOf(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keysWithPrefix(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.hasKeyWithPrefix(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keysWithPattern(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.hasKeyWithPattern(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordEqualTo</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.countWordsEqualTo(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsStartingWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.countWordsStartingWith(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="秒杀题目">秒杀题目</h2>
<h3 id="牛客-nc124-字典树的实现"><a
href="https://www.nowcoder.com/practice/a55a584bc0ca4a83a272680174be113b">牛客-NC124-字典树的实现</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304232231864.png" alt="牛客-NC124-字典树的实现" style="zoom:50%;" /></p>
<p>只需要使用 TrieMap 中的部分 API 封装一个 Trie 类即可解决该题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operators string字符串二维数组 the ops</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String[] trieU (String[][] operators) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String[] opera : operators) &#123;</span><br><span class="line">            <span class="keyword">if</span> (opera[<span class="number">0</span>].equals(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">                trie.insert(opera[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opera[<span class="number">0</span>].equals(<span class="string">&quot;2&quot;</span>)) &#123;</span><br><span class="line">                trie.delete(opera[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opera[<span class="number">0</span>].equals(<span class="string">&quot;3&quot;</span>)) &#123;</span><br><span class="line">                ans.add(trie.search(opera[<span class="number">1</span>]) ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opera[<span class="number">0</span>].equals(<span class="string">&quot;4&quot;</span>)) &#123;</span><br><span class="line">                ans.add(String.valueOf(trie.prefixNumber(opera[<span class="number">1</span>])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrieMap&lt;Object&gt; trieMap = <span class="keyword">new</span> <span class="title class_">TrieMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        trieMap.put(word, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        trieMap.remove(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> trieMap.containsKey(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">prefixNumber</span><span class="params">(String pre)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> trieMap.countWordsStartingWith(pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> V val;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> pass;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Character, TrieNode&lt;V&gt;&gt; children;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            val = <span class="literal">null</span>;</span><br><span class="line">            pass = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; root = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieMap</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">getNode</span><span class="params">(String key, TrieNode&lt;V&gt; node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode&lt;V&gt; p = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            p = p.children.get(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode&lt;V&gt; p = getNode(key, root);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || p.val == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode&lt;V&gt; node = root;</span><br><span class="line">        node.pass++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.children.containsKey(path)) &#123;</span><br><span class="line">                node.children.put(path, <span class="keyword">new</span> <span class="title class_">TrieNode</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children.get(path);</span><br><span class="line">            node.pass++;</span><br><span class="line">        &#125;</span><br><span class="line">        node.val = val;</span><br><span class="line">        node.end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        TrieNode&lt;V&gt; node = root;</span><br><span class="line">        node.pass--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (--node.children.get(path).pass == <span class="number">0</span>) &#123;</span><br><span class="line">                node.children.remove(path);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children.get(path);</span><br><span class="line">        &#125;</span><br><span class="line">        node.end--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsStartingWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode&lt;V&gt; node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(!node.children.containsKey(path)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children.get(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.pass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="力扣-208-实现-trie前缀树"><a
href="https://leetcode.cn/problems/implement-trie-prefix-tree/">力扣-208-实现
Trie（前缀树）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304241212143.png" alt="力扣-208-实现 Trie（前缀树）" style="zoom:50%;" /></p>
<p>只需要使用 TrieMap 中的部分 API 封装一个 Trie 类即可解决该题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrieMap&lt;Object&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">TrieMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        map.put(word, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.hasKeyWithPrefix(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="type">int</span> pass;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        V val;</span><br><span class="line">        HashMap&lt;Character, TrieNode&lt;V&gt;&gt; children;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            pass = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            val = <span class="literal">null</span>;</span><br><span class="line">            children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; root = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieMap</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrieNode&lt;V&gt; <span class="title function_">getNode</span><span class="params">(TrieNode&lt;V&gt; node, String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode&lt;V&gt; p = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            p = p.children.get(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode&lt;V&gt; p = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || p.val == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改或更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode&lt;V&gt; node = root;</span><br><span class="line">        node.pass++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.children.containsKey(path)) &#123;</span><br><span class="line">                node.children.put(path, <span class="keyword">new</span> <span class="title class_">TrieNode</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children.get(path);</span><br><span class="line">            node.pass++;</span><br><span class="line">        &#125;</span><br><span class="line">        node.val = val;</span><br><span class="line">        node.end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(root, prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="力扣-211-添加与搜索单词-数据结构设计"><a
href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">力扣-211-添加与搜索单词-数据结构设计</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202304241329322.png" alt="力扣-211-添加与搜索单词" style="zoom:50%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrieMap&lt;Object&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WordDictionary</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">TrieMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        map.put(word, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.hasKeyWithPattern(word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj.addWord(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="type">int</span> pass;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        V val;</span><br><span class="line">        HashMap&lt;Character, TrieNode&lt;V&gt;&gt; children;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            pass = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            val = <span class="literal">null</span>;</span><br><span class="line">            children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; root = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieMap</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">getNode</span><span class="params">(TrieNode&lt;V&gt; node, String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode&lt;V&gt; p = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            p = p.children.get(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode&lt;V&gt; p = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || p.val == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!containsKey(key)) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode&lt;V&gt; node = root;</span><br><span class="line">        node.pass++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.children.containsKey(path)) &#123;</span><br><span class="line">                node.children.put(path, <span class="keyword">new</span> <span class="title class_">TrieNode</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children.get(path);</span><br><span class="line">            node.pass++;</span><br><span class="line">        &#125;</span><br><span class="line">        node.val = val;</span><br><span class="line">        node.end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKeyWithPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> traverse(root, pattern, <span class="number">0</span>);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, String pattern, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == pattern.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.val != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (path != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> traverse(node.children.get(path), pattern, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : node.children.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (traverse(node.children.get(c), pattern, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="力扣-677-键值映射"><a
href="https://leetcode.cn/problems/map-sum-pairs/">力扣-677-键值映射</a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MapSum</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TrieMap&lt;Integer&gt; map = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MapSum</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">TrieMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        map.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        List&lt;String&gt; keys = map.keysWithPrefix(prefix);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            res += map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MapSum object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MapSum obj = new MapSum();</span></span><br><span class="line"><span class="comment"> * obj.insert(key,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.sum(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieMap</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="type">int</span> pass;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        V val;</span><br><span class="line">        HashMap&lt;Character, TrieNode&lt;V&gt;&gt; children;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            pass = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            val = <span class="literal">null</span>;</span><br><span class="line">            children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; root = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieMap</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode&lt;V&gt; <span class="title function_">getNode</span><span class="params">(TrieNode&lt;V&gt; node, String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode&lt;V&gt; p = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            p = p.children.get(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode&lt;V&gt; p = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || p.val == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, V val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode&lt;V&gt; node = root;</span><br><span class="line">        node.pass++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">path</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.children.containsKey(path)) &#123;</span><br><span class="line">                node.children.put(path, <span class="keyword">new</span> <span class="title class_">TrieNode</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children.get(path);</span><br><span class="line">            node.pass++;</span><br><span class="line">        &#125;</span><br><span class="line">        node.val = val;</span><br><span class="line">        node.end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        TrieNode&lt;V&gt; p = getNode(root, prefix);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(p, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(prefix), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TrieNode&lt;V&gt; node, StringBuilder path, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.val != <span class="literal">null</span>) &#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : node.children.keySet()) &#123;</span><br><span class="line">            path.append(c);</span><br><span class="line">            traverse(node.children.get(c), path, res);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>算法（第四版）</li>
<li>labuladong 的算法小抄</li>
<li>程序员代码指南</li>
<li>牛客网</li>
<li>力扣网</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法框架</category>
        <category>Trie</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法框架</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕算法必备技巧（叁）—— 双指针（数组篇）</title>
    <url>/article/9164570a.html</url>
    <content><![CDATA[<p>书接上篇<a
href="https://www.mrpersimmon.top/article/631e5355.html">手撕算法必备技巧（贰）
——
双指针（链表篇）</a>，前文提到了什么是双指针技巧，以及该技巧如何在链表中应用。本文主要讲解双指针技巧是如何解决大厂面试中常见的数组问题。</p>
<p>考察过该技巧的公司有阿里巴巴、腾讯、美团、拼多多、百度、华为等大厂。</p>
<p><strong>食用指南：</strong>
⭐️为一刷必做题，便于快速理解双指针技巧；无星题目可在刷完⭐️题目后再做，用于拓展学习双指针技巧如何与其他算法知识结合使用。</p>
<p><strong>日志更新：</strong>文章底部给出了更新日志，帮助小伙伴们快速知晓最近优化了哪些技巧，更新了哪些题目。</p>
<p>我相信，友好的讨论交流会让彼此快速进步！文章难免有疏漏之处，十分欢迎大家在评论区中批评指正。</p>
<span id="more"></span>
<p>前文已经阐述完了双指针技巧的使用，也给出了大量可以使用双指针技巧解决的链表题目。那么，接下来我们直接从题目入手，看看双指针技巧如何应用到数组题目上。</p>
<p>小提示，建议新同学要将题目的流程手绘一遍，这样更有助于理解！</p>
<h1 id="快慢指针技巧">快慢指针技巧</h1>
<h2 id="删除有序数组中的重复项力扣26"><a
href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">⭐️删除有序数组中的重复项（力扣26）</a></h2>
<h3 id="题目描述">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305191519619.png" style="zoom:50%;" /></p>
<h3 id="思路双指针">思路（双指针）</h3>
<p>首先，简单解释一下原地删除的概念：</p>
<p>原地删除就是不能新建一个数组，把去重后的元素放进新数组中，而是<strong>只能在原数组中去重</strong>。</p>
<p>题目中提到数组是一个升序数组，所以重复的元素一定连在一起。因为数组是一个连续的数据结构，如果找到一个重复元素，将其删除，然后还要把后面的元素迁移，这样时间复杂度非常高，为
<span class="math inline">\(O(n^2)\)</span> 级别。</p>
<p>如果想要一遍扫描就完成原地去重，那么就可以使用双指针技巧中的「快慢指针」技巧啦。</p>
<p>初始化快慢指针，快指针 <code>fast</code> 向前遍历，当
<code>fast</code> 找到一个和 <code>slow</code>
不相同的元素时，<code>slow</code> 前进一步，并给 <code>slow</code>
处的元素更新为 fast 指向的元素值。如此，便保证了
<code>nums[0...slow]</code> 都是无重复的元素。</p>
<p>直到 <code>fast</code> 遍历完整个数组，<code>nums[0...slow]</code>
就是最终的去重结果。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305191537264.gif" /></p>
<h3 id="参考代码">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 数组为空，返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化快慢指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">        <span class="comment">// 如果 fast 指向的元素 != slow 指向的元素</span></span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[slow]) &#123;</span><br><span class="line">            <span class="comment">// slow 前进一步</span></span><br><span class="line">            slow++;</span><br><span class="line">            <span class="comment">// 更新 slow 的元素值</span></span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            <span class="comment">// 由此保证了 nums[0...slow] 都是去重后的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快指针前进一步</span></span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nums[0...slow] 共有 slow + 1 个元素</span></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>n 是数组元素的个数，只需遍历一次数组即可完成去重。</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>只有到了常数个变量。</p>
<h2 id="删除排序链表中的重复元素力扣-83">⭐️<a
href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素（力扣
83）</a></h2>
<h3 id="题目描述-1">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305191556946.png" style="zoom:50%;" /></p>
<h3 id="思路双指针-1">思路（双指针）</h3>
<p>这道题和上一道题的数据去重几乎一样，唯一的区别就是把更新元素的操作变成了更新指针而已。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305192028834.gif" /></p>
<blockquote>
<p>可能会有读者会问，图中的链表节点仍旧挂在那里，这有被删除吗？这就不得不提到
Java
的垃圾回收机制了，<strong>对于这些不可达（或者说悬空）的链表节点，JVM
会自动回收。</strong>如果你使用的 C++
这类没有自动垃圾回收机制的语言，你需要在代码中手动释放掉那些节点。</p>
</blockquote>
<h3 id="参考代码-1">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 空链表直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.val != slow.val) &#123;</span><br><span class="line">            slow.next = fast; <span class="comment">// help GC</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 别忘了这个</span></span><br><span class="line">    <span class="comment">// 断开与后面重复元素的连接</span></span><br><span class="line">    slow.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-1">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>n 是链表长度，遍历一遍链表。</p>
<h3 id="空间复杂度-1">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>只用到了常数个变量。</p>
<h2 id="删除排序链表中重复的元素ii牛客"><a
href="https://www.nowcoder.com/practice/71cef9f8b5564579bf7ed93fbe0b2024">删除排序链表中重复的元素II（牛客）</a></h2>
<h3 id="题目描述-2">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305192112657.png" style="zoom:50%;" /></p>
<h3 id="思路双指针-2">思路（双指针）</h3>
<p>我们直接讲解进阶思路，也就是使用双指针的方法去解决。</p>
<p>为了便于处理删除第一个节点的情况，我们在链表的前面添加一个虚拟头节点。</p>
<p>我们要知道一点，在升序链表中所有重复的节点都是在一起的。利用这个特性，我们每次比较相邻的两个节点，如果两个节点元素相同，我们就再开一个循环将这段所有相同的节点都遍历过去。</p>
<p>然后让在这<strong>一连串相同的节点</strong>的前序节点，连上后续第一个不同的节点就可以啦。</p>
<p>最后返回时去掉虚拟头节点即可。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305192113102.gif" /></p>
<h3 id="参考代码-2">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 空链表直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加虚拟头节点，便于处理删除第一个链表节点的情况</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="comment">// 双指针: p.next, p.next.next</span></span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span> &amp;&amp; p.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果相邻两节点值相同</span></span><br><span class="line">        <span class="keyword">if</span> (p.next.val == p.next.next.val) &#123;</span><br><span class="line">            <span class="comment">// 记录值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> p.next.val;</span><br><span class="line">            <span class="comment">// 新开循环，将所有相同的节点都跳过</span></span><br><span class="line">            <span class="keyword">while</span> (p.next != <span class="literal">null</span> &amp;&amp; p.next.val == tmp) &#123;</span><br><span class="line">                p.next = p.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回时，去掉虚拟头节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然有两个 while 循环，但是我们只遍历了一次链表哦，内部的 while
循环帮助我们跳过了所有相同的节点，然后这些节点就不会再被访问了。</p>
</blockquote>
<h3 id="时间复杂度-2">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>n 为链表节点数，只遍历了一次链表。</p>
<h3 id="空间复杂度-2">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数个变量。</p>
<h2 id="移除元素力扣27"><a
href="https://leetcode.cn/problems/remove-element/">⭐️移除元素（力扣27）</a></h2>
<h3 id="题目描述-3">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305192032673.png" style="zoom:50%;" /></p>
<h3 id="思路双指针-3">思路（双指针）</h3>
<p>这道题和去重不同，我们需要原地删除指定元素。我们依旧准备快慢两个指针，快指针向前遍历，如果快指针
<code>fast</code>
遇到了指定元素，直接跳过；如果没有遇到指定元素，那么就要用
<code>fast</code> 处的元素值更新 <code>slow</code> 处的元素值，然后
<code>slow</code> 再前进一步。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305192041483.gif" /></p>
<h3 id="参考代码-3">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">            <span class="comment">// 先更新值，再移动 slow 指针</span></span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips！</strong></p>
<p>在有序数组去重中，我们是先移动 <code>slow</code>
指针，再更新值。在这里我们是先赋值再向前移动 <code>slow</code>
指针。这样可以保证 <code>nums[0...slow-1]</code>
是不包含指定元素的，最后的结果数组长度就是 <code>slow</code>。</p>
</blockquote>
<h3 id="时间复杂度-3">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>n 是数组的长度。</p>
<h3 id="空间复杂度-3">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>只用到了常数个指针变量。</p>
<h2 id="移动零力扣283"><a
href="https://leetcode.cn/problems/move-zeroes/">⭐️移动零（力扣283）</a></h2>
<h3 id="题目描述-4">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305201526811.png" style="zoom:50%;" /></p>
<h3 id="思路-i双指针">思路 I（双指针）</h3>
<p><strong>思路 1：</strong>
第一种思路很简单，借助「移除元素」的方法，把所有为 0 的元素移除，这样
nums[0...slow-1] 就都是不为 0 的元素，然后将nums[slow...nums.length-1]
用 0 填充。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305201638030.gif" /></p>
<h3 id="参考代码-i">参考代码 I</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除 nums 数组中所有的 0，返回不含 0 的数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> removeElement(nums, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 将 nums[p...nums.length-1] 的元素更新为 0</span></span><br><span class="line">    <span class="keyword">for</span> (; p &lt; nums.length; p++) &#123;</span><br><span class="line">        nums[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-i">时间复杂度 I</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<h3 id="空间复杂度-i">空间复杂度 I</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<h3 id="思路-ii双指针">思路 II（双指针）</h3>
<p>这个思路借助了快速排序的思想，快速排序首先要确定一个待分割的元素做中间点
x，然后把所有 &lt;= x 的元素放在 x 的左边，&gt; x 的元素放在 x
的右边。</p>
<p>在这道题中，我们将 0 作为中间点，不等于 0 的放在其左边，等于 0
的放在其右边。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305201654987.gif" /></p>
<h3 id="参考代码-ii">参考代码 II</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[fast];</span><br><span class="line">            <span class="comment">// 不等于 0 的放在左边</span></span><br><span class="line">            nums[fast] = nums[slow];</span><br><span class="line">            nums[slow] = tmp;</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等于 0 的直接跳过，相当于放在右边</span></span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-ii">时间复杂度 II</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<h3 id="空间复杂度-ii">空间复杂度 II</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<h2 id="滑动窗口算法">⭐️滑动窗口算法</h2>
<p>滑动窗口算法是快慢指针演化而来，我们会在后续专门用一篇文章讲解该算法。</p>
<p>滑动窗口算法的核心就是使用 <code>left</code> 和 <code>right</code>
两个指针，<code>left</code> 指针在后，<code>right</code>
指针在前，两个指针中间部分就是「窗口」，然后根据具体情况确定扩大和缩小「窗口」以解决问题。</p>
<h1 id="左右指针技巧">左右指针技巧</h1>
<h2 id="二分搜索问题">⭐️二分搜索问题</h2>
<p>谈到左右指针技巧的使用，最经典的当属二分搜索算法。我已在<a
href="https://juejin.cn/post/7228571126476521531">手撕算法必备技巧（壹）——
二分搜索</a>这篇文章全面阐述了二分搜索如何寻找一个数，或者寻找左右两边界问题。</p>
<h2 id="反转字符数组力扣344">⭐️<a
href="https://leetcode.cn/problems/reverse-string/">反转字符数组（力扣344）</a></h2>
<h3 id="题目描述-5">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305202336737.png" style="zoom:50%;" /></p>
<h3 id="思路左右指针">思路（左右指针）</h3>
<p>这道题很简单，使用左右指针，初始化分别指向 0 和 s.length - 1
，然后交换并移动指针就可以啦。</p>
<h3 id="参考代码-4">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        swap(s, left, right);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[i];</span><br><span class="line">    s[i] = s[j];</span><br><span class="line">    s[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-4">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<h3 id="空间复杂度-4">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<h2 id="有序数组的平方力扣977"><a
href="https://leetcode.cn/problems/squares-of-a-sorted-array/">⭐️有序数组的平方（力扣977）</a></h2>
<h3 id="题目描述-6">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305210016134.png" style="zoom:50%;" /></p>
<h3 id="思路左右指针-1">思路（左右指针）</h3>
<p>最简单的方法就是计算数组中的每个数，然后进行排序。这种算法的时间复杂度是
<span
class="math inline">\(O(nlogn)\)</span>，而且没有使用到数组是有序的这个条件。</p>
<p>更好地做法是，使用「左右指针」的方法，不仅可以让时间复杂度降到 <span
class="math inline">\(O(n)\)</span>
级别，还利用到了数组是有序的这个条件。</p>
<p>我们新建一个结果集数组，然后初始化左右指针，分别指向输入数组的 0 和 n
-
1，每次比较左右指针元素的平方大小。选择平方后更大的数<strong>逆序</strong>放入结果集中，然后被选择的指针和结果集指针进行移动。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305211041139.gif" /></p>
<h3 id="参考代码-5">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 空数组直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果集数组</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="comment">// 输入数组的左右指针，以及结果集的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>, i = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 谁的平方大，谁逆序放入结果集数组中</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] * nums[left] &lt;= nums[right] * nums[right]) &#123;</span><br><span class="line">            res[i] = nums[right] * nums[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[i] = nums[left] * nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理 left == right 的情况</span></span><br><span class="line">    res[i] = nums[left] * nums[left];</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-5">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>n 是 nums 数组的长度</p>
<h3 id="空间复杂度-5">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>除了必要的用于存储结果集数组的空间，只另外用到了常数个变量。</p>
<h2 id="n数之和问题">⭐️N数之和问题</h2>
<p>N 数之和问题包括两数之和、三数之和、... N
数之和。该问题会在后续单独出一篇文章进行讲解。</p>
<h1 id="总结">总结</h1>
<p>本文主要讲解了双指针的左右指针、快慢指针是如何在数组问题中使用的，也给自己挖了两个坑需要去填，一个是快慢指针中的<strong>滑动窗口</strong>算法问题，另一个是左右指针中的
<strong>N 数之和</strong>问题。</p>
<p>希望以上内容可以帮助到你，让你变得更强，大家加油！</p>
<h1 id="参考资料">参考资料</h1>
<ol type="1">
<li>力扣网</li>
<li>牛客网</li>
<li>算法基地 - github</li>
<li>labuladong 的算法小抄</li>
<li>代码随想录</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/article/2362a8ea.html</url>
    <content><![CDATA[<h3 id="相似解法题目多元组">相似解法题目多元组</h3>
<ul>
<li><p><strong>双指针：</strong>&lt; BM5 合并 k 个已排序的链表，BM6
判断链表中是否有环， BM7 链表中环的入口点，BM8 链表中倒数最后 k
个节点，BM9 删除链表的倒数第 n 个节点，BM10
两个链表的第一个公共节点，BM13 判断一个链表是否为回文结构，BM14
链表的奇偶重排&gt;</p></li>
<li><p><strong>环：</strong>&lt; BM6 判断链表中是否有环, BM7
链表中环的入口点 &gt;</p></li>
<li><p><strong>双指针定位倒数节点：</strong>&lt; BM8 链表中倒数最后 k
个节点, BM9 删除链表的倒数第 n 个节点 &gt;</p></li>
<li><p><strong>反转链表：</strong>&lt; BM1 反转链表, BM11
链表相加(二)&gt;</p></li>
<li><p><strong>归并排序：</strong>&lt; BM5 合并 k 个已排序的链表，BM12
单链表的排序，BM20 数组中的逆序对 &gt;</p></li>
</ul>
<span id="more"></span>
<h3 id="bm5-合并-k-个已排序的链表"><a
href="https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6">BM5
合并 k 个已排序的链表</a></h3>
<h4 id="描述">描述</h4>
<p>合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。</p>
<h4 id="f1归并排序">F1：归并排序</h4>
<h5 id="思路">思路</h5>
<ul>
<li>双指针、归并排序、分治</li>
</ul>
<h5 id="步骤">步骤</h5>
<ol type="1">
<li>从链表数组的首和尾开始，每次划分从中间开始划分，划分成两半，得到左边
n/2 个链表和右边 n/2 个链表。</li>
<li>继续不断递归划分，直到每部分链表数为 1。</li>
<li>将划分好的相邻两部分链表，按照两个有序链表合并的方式合并，合并好的两部分继续向上合并，直到最终合并成一个链表。</li>
</ol>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/DM_20230406215647_001.gif"
alt="归并排序合并 k 个升序链表" />
<figcaption aria-hidden="true">归并排序合并 k 个升序链表</figcaption>
</figure>
<h5 id="代码">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> divideMerge(lists, <span class="number">0</span>, lists.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 划分合并区间函数</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">divideMerge</span><span class="params">(ArrayList&lt;ListNode&gt; lists, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left == right) <span class="comment">// 中间 1 个的情况</span></span><br><span class="line">        <span class="keyword">return</span> lists.get(left);</span><br><span class="line">    <span class="comment">// 从中间分成两段，再将合并好的两段合并</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> merge(divideMerge(lists, left, mid), divideMerge(lists, mid + <span class="number">1</span>, right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个有序链表</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">    <span class="comment">// 一个链表为空，直接返回另一个</span></span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    <span class="comment">// 添加一个表头</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pivot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pivot;</span><br><span class="line">    <span class="comment">// 两个链表都不能为空</span></span><br><span class="line">    <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 取较小值的节点</span></span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">            cur.next = list1;</span><br><span class="line">            <span class="comment">// 只移动取了值的指针</span></span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = list2;</span><br><span class="line">            <span class="comment">// 只移动取了值的指针</span></span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针后移</span></span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 哪个链表还剩，直接连在后面</span></span><br><span class="line">    <span class="keyword">if</span> (list1 != <span class="literal">null</span>)</span><br><span class="line">        cur.next = list1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cur.next = list2;</span><br><span class="line">    <span class="comment">// 返回值去掉表头</span></span><br><span class="line">    <span class="keyword">return</span> pivot.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度">时间复杂度</h5>
<p><span class="math inline">\(O(nlog_2k)\)</span></p>
<p>n
为所有链表总节点数，分治为二叉树型递归，最坏情况下二叉树每层合并都是
<span class="math inline">\(O(n)\)</span> 个节点，因为分治一共有 <span
class="math inline">\(O(log_2k)\)</span> 层。</p>
<h5 id="空间复杂度">空间复杂度</h5>
<p><span class="math inline">\(O(log_2k)\)</span></p>
<p>最坏情况下递归 <span class="math inline">\(log_2k\)</span> 层，需要
<span class="math inline">\(log_2k\)</span> 的递归栈。</p>
<h4 id="f2优先级队列">F2：优先级队列</h4>
<h5 id="思路-1">思路</h5>
<p>不同于方法 1，该方法直接使用 k 个指针，每次比较得出 k
个数字中的最小值。</p>
<p>每次优先级队列中有 k
个元素，可以直接拿出最小的元素，再插入下一个元素，相当于每次都是链表的 k
个指针在比较大小，只移动最小元素的指针。</p>
<h5 id="步骤-1">步骤</h5>
<ol type="1">
<li>构造一个小根堆（优先级队列）；</li>
<li>先遍历 k 个链表头，将不是空节点的节点加入小根堆；</li>
<li>每次依次弹出小根堆中的最小元素，将其连接在合并后的链表后面，然后将这个节点的原链表中的后序节点（不为空的话）加入队列，与方法
1 归并排序双指针的过程类似。</li>
</ol>
<h5 id="代码-1">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;</span><br><span class="line">    <span class="comment">// 小根堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((l1, l2) -&gt; l1.val - l2.val);</span><br><span class="line">    <span class="comment">// 遍历所有链表的头节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 不为空加入小根堆</span></span><br><span class="line">        <span class="keyword">if</span> (lists.get(i) != <span class="literal">null</span>)</span><br><span class="line">            pq.add(lists.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 哨兵表头</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pivot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pivot;</span><br><span class="line">    <span class="comment">// 直到小根堆为空</span></span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 取出最小节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pollNode</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        <span class="comment">// 连接</span></span><br><span class="line">        cur.next = pollNode;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        <span class="comment">// 如果当前最小节点的后序节点不为空，加入小根堆</span></span><br><span class="line">        <span class="keyword">if</span> (pollNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pq.add(pollNode.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉哨兵节点</span></span><br><span class="line">    <span class="keyword">return</span> pivot.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-1">时间复杂度</h5>
<p><span class="math inline">\(O(nlog_2k)\)</span></p>
<p>n 为所有链表总节点数，最坏要遍历所有节点，每次加入优先级队列排序需要
<span class="math inline">\(O(log_2k)\)</span></p>
<h5 id="空间复杂度-1">空间复杂度</h5>
<p><span class="math inline">\(O(k)\)</span></p>
<p>优先队列的大小不会超过 k</p>
<hr />
<h3 id="bm6-判断链表中是否有环"><a
href="https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9">BM6
判断链表中是否有环</a></h3>
<h4 id="描述-1">描述</h4>
<p>判断给定的链表中是否有环。如果有环则返回 true，否则返回 false。</p>
<h4 id="f1双指针">F1：双指针</h4>
<h5 id="思路-2">思路</h5>
<p><strong>线性与环形链表特点：</strong></p>
<ul>
<li><p>线性链表末尾一定有 null。</p></li>
<li><p><strong>环形链表的环一定在末尾，末尾没有 null
了。</strong></p></li>
</ul>
<p><strong>线性与环形链表结束条件：</strong></p>
<ul>
<li><p>线性链表的结束条件就是遍历到 null。</p></li>
<li><p><strong>环形链表会不断循环，需要借助双指针才能结束。</strong>同向访问的双指针，因为速度不同，只要有环，二者一定能相遇。</p></li>
</ul>
<h5 id="步骤-2">步骤</h5>
<ol type="1">
<li>设置快慢两指针，初始都指向链表头；</li>
<li>遍历链表，快指针每次走两步，慢指针每次走一步；</li>
<li>如果快指针到了链表末尾，说明没有环，因为它每次走两步，所以要验证连续两步是否为
null；</li>
<li>如果链表有环，那快慢双指针会在环内循环，因为快指针每次走两步，因此快指针会在环内追到慢指针，二者相遇就代表有环。</li>
</ol>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/DM_20230405143207_001.gif"
alt="双指针判断链表是否有环" />
<figcaption aria-hidden="true">双指针判断链表是否有环</figcaption>
</figure>
<h5 id="代码-2">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 先判断链表为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 1. 设置快慢两指针，初始都指向链表头</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 2. 遍历链表</span></span><br><span class="line">    <span class="comment">// 3. 如果没环，fast 会先到链表尾</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 快指针移动两步</span></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 慢指针移动一步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="comment">// 相遇则有环</span></span><br><span class="line">        <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到末尾，则没有环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-2">时间复杂度</h5>
<p><span class="math inline">\(O(M)\)</span></p>
<p>最坏情况下遍历链表 n 个节点。</p>
<h5 id="空间复杂度-2">空间复杂度</h5>
<p><span class="math inline">\(O(1)\)</span></p>
<p>仅使用了两个指针，没有额外辅助空间。</p>
<hr />
<h3 id="bm7-链表中环的入口点"><a
href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4">BM7
链表中环的入口点</a></h3>
<h4 id="描述-2">描述</h4>
<p>给一个长度为 n
链表，若其中包含环，请找出该链表的环的入口结点，否则，返回 null。</p>
<h5 id="分解任务">分解任务</h5>
<ol type="1">
<li>判断链表是否有环；</li>
<li>在有环的链表中找到环的入口。</li>
</ol>
<h4 id="f1双指针-1">F1：双指针</h4>
<h5 id="思路-3">思路</h5>
<p><strong>如何找到环的入口？</strong></p>
<p>一个有环链表。</p>
<p>假设快指针在环中走了 <span class="math inline">\(n\)</span>
圈，慢指针走了 <span class="math inline">\(m\)</span> 圈，两者相遇。</p>
<p>链表头节点到环入口点距离为 <span
class="math inline">\(x\)</span>，环入口到相遇点距离为 <span
class="math inline">\(y\)</span>，相遇点到环入口点距离为 <span
class="math inline">\(z\)</span>。</p>
<p>快指针一共走了 <span class="math inline">\(x + n(y + z) + y\)</span>
步，慢指针一共走了 <span class="math inline">\(x + m(y + z) + y\)</span>
步。</p>
<p>快指针走的步数是慢指针的两倍，则 <span class="math display">\[
x + n(y + z) + y = 2(x + m(y + z) + y)
\]</span> 进一步推导， <span class="math display">\[
x+y=(n-2m)(y+z)
\]</span> 因为环的大小是 <span
class="math inline">\(y+z\)</span>，说明从链表头经过环入口到达相遇地方经过的距离等于整数倍环的大小。那么，我们从头开始遍历到相遇位置，和从相遇位置开始在环中遍历，会使用相同的步数，而双方最后都会经过入口到相遇位置这
<span class="math inline">\(y\)</span> 个节点，说明这 <span
class="math inline">\(y\)</span>
个节点它们就是重叠遍历的，那它们从入口位置就相遇了，这样就找到了入口节点。</p>
<h5 id="步骤-3">步骤</h5>
<ol type="1">
<li>使用 BM6 方法判断链表是否有环，并找到相遇节点。</li>
<li>慢指针继续在相遇节点，快指针回到链表头，两个指针同步逐个元素开始遍历链表。</li>
<li>两者再次相遇的地方就是环的入口。</li>
</ol>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/DM_20230405143356_001.gif"
alt="双指针找环入口" />
<figcaption aria-hidden="true">双指针找环入口</figcaption>
</figure>
<h5 id="代码-3">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找链表中环的入口节点</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">entryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> hasCycle(pHead);</span><br><span class="line">    <span class="comment">// 没有环</span></span><br><span class="line">    <span class="keyword">if</span> (slow == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 有环</span></span><br><span class="line">    <span class="comment">// 快指针回到表头</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> pHead;</span><br><span class="line">    <span class="comment">// 再次相遇即是环入口</span></span><br><span class="line">    <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断有没有环</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 先判断链表为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 快慢双指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 如果没环，快指针会先到链表尾</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="comment">// 相遇则有环，返回相遇的节点</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到末尾说明没有换，返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-3">时间复杂度</h5>
<p><span class="math inline">\(O(n)\)</span></p>
<p>最坏情况下遍历链表两次</p>
<h5 id="空间复杂度-3">空间复杂度</h5>
<p><span class="math inline">\(O(1)\)</span></p>
<p>使用了常数个指针，没有额外辅助空间</p>
<hr />
<h3 id="bm8-链表中倒数最后-k-个节点"><a
href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9">BM8
链表中倒数最后 k 个节点</a></h3>
<h4 id="描述-3">描述</h4>
<p>输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第
k 个节点。</p>
<p>如果该链表长度小于 k，请返回一个长度为 0 的链表。</p>
<h4 id="f1双指针推荐">F1：双指针（推荐）</h4>
<h5 id="思路-4">思路</h5>
<p>链表无法逆序遍历。</p>
<p><strong>如果当前我们处于倒数第 k 的位置上，即距离链表尾的距离是
k。</strong></p>
<p><strong>我们假设双指针指向这两个位置，二者同步向前移动，当前面快指针到了链表尾的时候，两个指针之间的距离还是
k。</strong></p>
<p>虽然无法让指针逆向移动，但是上述思路却可以正向实施。</p>
<h5 id="步骤-4">步骤</h5>
<ol type="1">
<li>准备一个快指针，从链表头开始，在链表上先走 k 步。</li>
<li>准备慢指针指向原始链表头，代表当前节点，快慢指针之间的距离一直都是
k。</li>
<li>快慢指针同步移动，当快指针到达链表尾部的时候，慢指针正好到了倒数 k
个节点的位置。</li>
</ol>
<h5 id="代码-4">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span><span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> pHead;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> pHead;</span><br><span class="line">    <span class="comment">// 快指针先行 k 步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 达不到 k 步，说明链表过短。</span></span><br><span class="line">            <span class="type">return</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快慢指针同步，快指针先到底，慢指针指向倒数第 k 个</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-4">时间复杂度</h5>
<p><span class="math inline">\(O(n)\)</span></p>
<p>总共遍历 n 个链表节点</p>
<h5 id="空间复杂度-4">空间复杂度</h5>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，无额外辅助空间使用</p>
<h4 id="f2先找长度再找最后-k">F2：先找长度再找最后 k</h4>
<h5 id="思路-5">思路</h5>
<p>链表不能逆向遍历，也不能直接访问。但是对于倒数第 k
个位置，我们只需知道是正数多少位，还是可以直接遍历得到的。</p>
<h5 id="步骤-5">步骤</h5>
<ol type="1">
<li>遍历链表，找到链表的长度；</li>
<li>如果链表长度小于 k，返回空节点。</li>
<li>如果链表长度够长，我们从头节点往后遍历 n - k 次即可。</li>
</ol>
<h5 id="代码-5">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span><span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pHead;</span><br><span class="line">    <span class="comment">// 遍历链表，统计链表长度</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        n ++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表长度不足 k，返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = pHead;</span><br><span class="line">    <span class="comment">// 遍历 n - k 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - k; i++) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-5">时间复杂度</h5>
<p><span class="math inline">\(O(n)\)</span></p>
<p>最坏情况下，两次遍历 n 个链表元素</p>
<h5 id="空间复杂度-5">空间复杂度</h5>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，无额外辅助空间使用</p>
<hr />
<h3 id="bm9-删除链表的倒数第-n-个节点">BM9 删除链表的倒数第 n
个节点</h3>
<h4 id="描述-4">描述</h4>
<p>给定一个链表，删除链表的倒数第 n 个节点并返回链表的头指针</p>
<p>例如，给出的链表为: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, n =
2。删除了链表的倒数第 n 个节点，链表变为 1 -&gt; 2 -&gt; 3 -&gt; 5。</p>
<p>备注：题目保证 n 一定是有效的。</p>
<h4 id="f1三指针">F1：三指针</h4>
<h5 id="思路-6">思路</h5>
<p>思路与 BM8 链表中倒数最后 k
个节点的思路基本一致，不同的是，在其基础上增加一个哨兵表头以及一个指针。</p>
<h5 id="步骤-6">步骤</h5>
<ol type="1">
<li>给链表添加一个表头，处理删掉第一个元素时比较方便。</li>
<li>准备一个快指针，在链表上先走 n 步。</li>
<li>准备一个慢指针指向原始链表头，一个前序指针指向添加的表头。快慢指针之间的距离一直都是
n，前序指针始终指向慢指针的前序节点。</li>
<li>三指针同步向前移动，当快指针到达链表尾部 null
的时候，慢指针正好到了倒数第 n 个节点。</li>
<li>将前序指针指向的前序节点的指针指向慢指针后一个节点，删除掉慢指针指向的节点。</li>
</ol>
<h5 id="代码-6">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加表头</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pivot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    pivot.next = head;</span><br><span class="line">    <span class="comment">// 前序指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> pivot;</span><br><span class="line">    <span class="comment">// 慢指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 快指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 快指针先走 n 步</span></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123; <span class="comment">// 题目保证了 n 一定有效</span></span><br><span class="line">        fast = fast.next;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 三指针同步前移，快指针到达末尾，慢指针就到了倒数第 n 个位置</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除慢指针节点</span></span><br><span class="line">    pre.next = slow.next;</span><br><span class="line">    <span class="comment">// 去掉表头返回</span></span><br><span class="line">    <span class="keyword">return</span> pivot.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-6">时间复杂度</h5>
<p><span class="math inline">\(O(n)\)</span></p>
<p>最坏情况下，遍历 n 个链表节点。</p>
<h5 id="空间复杂度-6">空间复杂度</h5>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，无额外辅助空间使用</p>
<hr />
<h3 id="bm10-两个链表的第一个公共节点"><a
href="https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08">BM10
两个链表的第一个公共节点</a></h3>
<h4 id="描述-5">描述</h4>
<p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。</p>
<h4 id="f1双指针-2">F1：双指针</h4>
<h5 id="思路-7">思路</h5>
<p>使用两个指针 p1，p2，一个从链表 1 的头节点开始遍历，一个从链表 2
的头节点开始遍历。</p>
<p>p1、p2 一起遍历，若 p1 先走到链表 1 的尽头（null），则从链表 2
的头节点继续遍历。同样的，如果 p2 先走到链表 2 的尽头（null），则从链表
1 的头节点继续遍历，也就是说，p1 和 p2 都会遍历链表 1 和链表 2.</p>
<p>两个指针，同样的速度，走完同样的长度（链表 1 + 链表
2），不管两条链表有无相同节点，都能够同时到达终点。</p>
<p>因此，如何确定公共节点：</p>
<ul>
<li>有公共节点的时候，p1 和 p2
必会相遇，因为长度一样，速度也一样，必会走到相同的地方。两者相遇的节点就是第一个公共的节点。</li>
<li>无公共节点的时候，此时 p1 和 p2 都会走到终点，那么他们此时都是
null，也算相等。</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/DM_20230404201233_001.gif"
alt="双指针确定两链表第一个公共节点" />
<figcaption
aria-hidden="true">双指针确定两链表第一个公共节点</figcaption>
</figure>
<h5 id="代码-7">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 定义两个指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> pHead1, p2 = pHead2;</span><br><span class="line">    <span class="comment">// 2. 指针遍历两个链表</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// p1 到链表 1 终点就从链表 2 开始遍历，否则继续向后遍历</span></span><br><span class="line">        p1 = (p1 == <span class="literal">null</span>) ? pHead2 : p1.next;</span><br><span class="line">        <span class="comment">// p2 到链表 2 终点就从链表 1 开始遍历，否则继续向后遍历</span></span><br><span class="line">        p2 = (p2 == <span class="literal">null</span>) ? pHead1 : p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 相遇节点就是两个链表的第一个公共节点</span></span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-7">时间复杂度</h5>
<p><span class="math inline">\(O(m+n)\)</span></p>
<p>链表 1 和链表 2 的长度之和。</p>
<h5 id="空间复杂度-7">空间复杂度</h5>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，无额外辅助空间使用。</p>
<h3 id="bm13-判断一个链表是否为回文结构"><a
href="https://www.nowcoder.com/practice/3fed228444e740c8be66232ce8b87c2f">BM13
判断一个链表是否为回文结构</a></h3>
<h4 id="描述-6">描述</h4>
<p>给定一个链表，请判断该链表是否为回文结构。</p>
<p>回文是指该字符串正序逆序完全一致。</p>
<h4 id="f1栈逆序">F1：栈逆序</h4>
<h5 id="步骤-7">步骤</h5>
<ol type="1">
<li>遍历链表，将链表元素依次加入栈中。</li>
<li>依次从栈中弹出元素，和链表的顺序遍历比较，如果都是相同的，那么就是回文，否则就不是。</li>
</ol>
<h5 id="代码-8">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPail</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 遍历节点，放入栈中</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(cur.val);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// 正向遍历与反向遍历对比</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">popVal</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="comment">// 如果值不等，不是回文结构</span></span><br><span class="line">        <span class="keyword">if</span>(popVal != cur.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部相等，是回文结构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-8">时间复杂度</h5>
<p><span class="math inline">\(O(n)\)</span></p>
<p>n 为链表长度，遍历链表入栈为 <span
class="math inline">\(O(n)\)</span>，后续再次遍历链表和栈。</p>
<h5 id="空间复杂度-8">空间复杂度</h5>
<p><span class="math inline">\(O(n)\)</span></p>
<p>记录链表元素的辅助栈长度和链表相同。</p>
<h4 id="f2-双指针寻中逆序">F2: 双指针寻中逆序</h4>
<h5 id="步骤-8">步骤</h5>
<ol type="1">
<li>慢指针每次走一个节点，快指针每次走两个节点，快指针到达链表终点（null）时，慢指针刚好到了链表中点。</li>
<li>从中点位置开始，将后半段链表反转。</li>
<li>双指针左指针指向头节点，右指针指向反转后的头节点（原链表的尾节点），都向中间遍历，依次比较对应位置的节点值是否相等。</li>
</ol>
<p><strong>快慢指针寻找中点：</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/DM_20230404222009_001.gif"
alt="双指针寻找中点" />
<figcaption aria-hidden="true">双指针寻找中点</figcaption>
</figure>
<p><strong>链表反转及比较：</strong></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/DM_20230405222026_001.gif"
alt="链表反转及比较" />
<figcaption aria-hidden="true">链表反转及比较</figcaption>
</figure>
<h5 id="代码-9">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPail</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 空链表为回文结构</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 准备快慢双指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 双指针寻找中点</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中点处开始反转</span></span><br><span class="line">    slow = reverse(slow);</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 比较快慢指针所指的值是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (slow.val != fast.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反转链表</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-9">时间复杂度</h5>
<p><span class="math inline">\(O(n)\)</span></p>
<p>n 为链表长度，双指针找到中点遍历半个链表，后续反转链表为 <span
class="math inline">\(O(n)\)</span>，然后再遍历两份半个链表。</p>
<h5 id="空间复杂度-9">空间复杂度</h5>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，没有额外辅助空间。</p>
<hr />
<h3 id="bm14-链表的奇偶重排"><a
href="https://www.nowcoder.com/practice/02bf49ea45cd486daa031614f9bd6fc3">BM14
链表的奇偶重排</a></h3>
<h4 id="描述-7">描述</h4>
<p>给定一个单链表，请设定一个函数，将链表的<strong>奇数位</strong>节点和<strong>偶数位</strong>节点分别放在一起，重排后输出。</p>
<p>注意是节点的编号而非节点的数值。</p>
<h4 id="f1双指针-3">F1：双指针</h4>
<h5 id="思路-8">思路</h5>
<p>第一个节点是奇数位，第二个节点是偶数位，第三个节点又是奇数位，因此，可以断掉节点
1 和节点 2 之间的连接，节点 1 的 next 指向节点 2 后面的节点 3。断掉节点
2 与节点 3 之间的连接，指向节点 4 节点，如此直到链表结束。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/DM_20230405005934_001.gif"
alt="双指针奇偶位重排" />
<figcaption aria-hidden="true">双指针奇偶位重排</figcaption>
</figure>
<h5 id="步骤-9">步骤</h5>
<ol type="1">
<li><p>判断空链表的情况，如果链表为空，不用重排。</p></li>
<li><p>使用双指针 odd 和 even
分别遍历奇数节点和偶数节点，并给偶数节点链表一个头。</p></li>
<li><p>上述过程，每次遍历两个节点，且 even 在后面，因此每轮循环用 even
检查后两个元素是否为
null，如果不是，再进入循环进行上述连接过程。</p></li>
<li><p>将偶数节点头接在奇数位最后一个节点后面，再返回头部。</p></li>
</ol>
<h5 id="代码-10">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 如果链表为空，不用重排</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 2.1 奇数位节点指针指向表头</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">odd</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 2.2 偶数位节点指针指向第二个节点，可能为空</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">even</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="comment">// 2.2 偶数位头节点的哨兵节点，保留住偶数位头节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">evenPivot</span> <span class="operator">=</span> even;</span><br><span class="line">    <span class="comment">// 3. 偶数位节点及后序节点不为空，可以继续循环</span></span><br><span class="line">    <span class="keyword">while</span> (even != <span class="literal">null</span> &amp;&amp; even.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.1 奇数位节点指针连接偶数位节点的后一个</span></span><br><span class="line">        odd.next = even.next;</span><br><span class="line">        <span class="comment">// 3.2 奇数位指针到下一个奇数位节点</span></span><br><span class="line">        odd = odd.next;</span><br><span class="line">        <span class="comment">// 3.3 偶数位指针节点连接奇数位节点的后一个</span></span><br><span class="line">        even.next = odd.next;</span><br><span class="line">        <span class="comment">// 3.4 偶数位指针进入下一个偶数位节点</span></span><br><span class="line">        even = even.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 偶数位节点的头连在奇数位链表尾节点的后面</span></span><br><span class="line">    odd.next = evenPivot;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-10">时间复杂度</h5>
<p><span class="math inline">\(O(n)\)</span></p>
<p>遍历一次链表所有节点。</p>
<h5 id="空间复杂度-10">空间复杂度</h5>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，没有额外辅助空间。</p>
<hr />
<h3 id="bm11-链表相加二"><a
href="https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b">BM11
链表相加(二)</a></h3>
<h4 id="描述-8">描述</h4>
<p>假设链表中每一个节点的值都在 0 - 9
之间，那么链表整体就可以代表一个整数。</p>
<p>给定两个这种链表，请生成代表两个整数相加值的结果链表。</p>
<p>例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为
6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/image-20230405192958401.png" alt="示例" style="zoom:50%;" /></p>
<h4 id="f1反转链表">F1：反转链表</h4>
<h5 id="思路-9">思路</h5>
<p>链表无法逆序遍历，我们可以将两个链表都反转，然后进行相加运算。</p>
<h5 id="步骤-10">步骤</h5>
<ol type="1">
<li>任意一个链表为空，返回另一个链表即可，因为链表为空相当于 0。</li>
<li>反转两个待相加的链表。</li>
<li>设置返回链表的链表头，设置进位 carry = 0。</li>
<li>从头开始遍历两个链表，直到两个链表节点都为空且 carry 也不为
1。每次取出不为空的链表节点值，为空就设置为 0，将两个数字与 carry
相加，然后查看是否进位，将进位后的结果（对 10
取模）加入新的链表节点，连接在返回链表的后面，并继续向后遍历。</li>
<li>返回前将结果链表再反转回来。</li>
</ol>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/DM_20230405195407_001.gif"
alt="链表相加" />
<figcaption aria-hidden="true">链表相加</figcaption>
</figure>
<h5 id="代码-11">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addInList</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 任意一个链表为空，返回另一个</span></span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head2;</span><br><span class="line">    <span class="keyword">if</span> (head2 == <span class="literal">null</span>)</span><br><span class="line">       <span class="keyword">return</span> head1;</span><br><span class="line">    <span class="comment">// 2. 反转两个链表</span></span><br><span class="line">    head1 = reverse(head1);</span><br><span class="line">    head2 = reverse(head2);</span><br><span class="line">    <span class="comment">// 3. 添加表头，设置进位</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pivot</span> <span class="operator">=</span> ans;</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="comment">// 4. 只要某个链表不为空，或者还有进位</span></span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="literal">null</span> || head2 != <span class="literal">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 链表不为空则取其值，否则设为 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> head1 == <span class="literal">null</span> ? <span class="number">0</span> : head1.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> head2 == <span class="literal">null</span> ? <span class="number">0</span> : head2.val;</span><br><span class="line">        <span class="comment">// 相加</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> val1 + val2 + carry;</span><br><span class="line">        <span class="comment">// 获取进位</span></span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 获取节点值</span></span><br><span class="line">        sum %= <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 结果链表添加节点</span></span><br><span class="line">        pivot.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line">        pivot = pivot.next;</span><br><span class="line">        <span class="comment">// 待相加链表节点不为空，则向下移动</span></span><br><span class="line">        <span class="keyword">if</span> (head1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverse(ans.next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-11">时间复杂度</h5>
<p><span class="math inline">\(O(max(m,n))\)</span></p>
<p>其中 m 与 n 分别为两个链表的长度，反转链表三次，复杂度分别为 <span
class="math inline">\(O(n)\)</span>、<span
class="math inline">\(O(m)\)</span>、<span
class="math inline">\(O(max(m,n))\)</span>，相加过程也是遍历较长的链表。</p>
<h5 id="空间复杂度-11">空间复杂度</h5>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，没有额外辅助空间，返回的新链表属于必要空间。</p>
<hr />
<h3 id="bm12-单链表的排序"><a
href="https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08?tpId=295&amp;tqId=1008897&amp;ru=%2Fpractice%2F65cfde9e5b9b4cf2b6bafa5f3ef33fa6">BM12
单链表的排序</a></h3>
<h4 id="描述-9">描述</h4>
<p>给定一个节点数为n的无序单链表，对其按升序排序。</p>
<h4 id="f1归并排序-1">F1：归并排序</h4>
<h5 id="思路-10">思路</h5>
<p><strong>如何合并呢？</strong></p>
<p>在合并阶段可以参考 <strong>BM4
合并两个有序链表</strong>，两个链表逐渐取最小的元素即可。</p>
<p><strong>如何划分呢？</strong></p>
<p>常规数组的归并排序是分治思想，即将数组从中间元素开始划分，然后将划分后的子数组作为一个要排序的数组，再将排好序的两个子数组合并成一个完整的有序数组，因此采用的是递归。</p>
<p>在链表中，我们也可以使用同样的方式，只需找到中间节点的前一个节点，将其断开，就可以将链表分成两个子链表，然后继续划分，直到最小，然后向上依次合并。</p>
<ul>
<li><strong>终止条件：</strong>当子链表划分到为空或者只剩一个节点时，不再继续划分，向上合并。</li>
<li><strong>返回值：</strong>每次返回两个排好序且合并好的子链表。</li>
<li><strong>本级任务：</strong>找到这个链表的中间节点，从前面断开，分为左右两个子链表，进入子问题排序。</li>
</ul>
<p><strong>如何找中间节点呢？</strong></p>
<p>可以参靠 <strong>BM13 判断一个链表是否是回文结构</strong> 的方法 2
双指针寻中法，快指针每次两步，慢指针每次一步，当快指针到达链表尾的时候，慢指针正好走了快指针距离的一半，为中间节点。</p>
<h5 id="步骤-11">步骤</h5>
<ol type="1">
<li>首先判断链表为空或者只有一个元素，直接就是有序的。</li>
<li>准备三个指针，快指针 right 每次走两步，慢指针 mid
每次走一步，前序指针 left 每次跟在 mid
前一个位置。三个指针遍历链表，当快指针到达链表尾部的时候，慢指针刚好走了链表的一半，正好是中间位置。</li>
<li>从 left 位置将链表断开，刚好分成两个子问题开始递归。</li>
<li>将子问题得到的链表合并。</li>
</ol>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/DM_20230406224214_001.gif"
alt="双指针归并完成单链表升序" />
<figcaption aria-hidden="true">双指针归并完成单链表升序</figcaption>
</figure>
<h5 id="代码-12">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortInList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 链表为空或只有一个元素，直接就是有序的，返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 构建三个指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">    <span class="comment">// 右边的指针到达链表终点时，中间的指针指向该段链表的中间节点</span></span><br><span class="line">    <span class="keyword">while</span> (right != <span class="literal">null</span> &amp;&amp; right.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        right = right.next.next;</span><br><span class="line">        mid = mid.next;</span><br><span class="line">        left = left.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中间指针的前序指针指向左段的最后一个节点，从这里断开</span></span><br><span class="line">    left.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 分成两段排序，合并排好序的两段</span></span><br><span class="line">    <span class="keyword">return</span> merge(sortInList(head), sortInList(mid));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序链表</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">    <span class="comment">// 一个链表为空，直接返回另一个</span></span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    <span class="comment">// 添加一个表头</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pivot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pivot;</span><br><span class="line">    <span class="comment">// 两个链表都不能为空</span></span><br><span class="line">    <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 取较小值的节点</span></span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">            cur.next = list1;</span><br><span class="line">            <span class="comment">// 只移动取了值的指针</span></span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = list2;</span><br><span class="line">            <span class="comment">// 只移动取了值的指针</span></span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针后移</span></span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 哪个链表还剩，直接连在后面</span></span><br><span class="line">    <span class="keyword">if</span> (list1 != <span class="literal">null</span>)</span><br><span class="line">        cur.next = list1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cur.next = list2;</span><br><span class="line">    <span class="comment">// 返回值去掉表头</span></span><br><span class="line">    <span class="keyword">return</span> pivot.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-12">时间复杂度</h5>
<p><span class="math inline">\(O(nlog_2n)\)</span></p>
<p>每一级划分最坏需要遍历链表全部元素，因此 <span
class="math inline">\(O(n)\)</span>，每一级合并都是将同级的子问题链表遍历合并，因此也为
<span class="math inline">\(O(n)\)</span>，分治划分为二叉树型，一共有
<span class="math inline">\(O(log_2n)\)</span> 层，因此复杂度为 <span
class="math inline">\(O((n + n) * log_2n)\)</span> = <span
class="math inline">\(O(nlog_2n)\)</span></p>
<h5 id="空间复杂度-12">空间复杂度</h5>
<p><span class="math inline">\(O(log_2n)\)</span></p>
<p>递归栈的深度最坏为树形递归的深度，<span
class="math inline">\(log_2n\)</span> 层。</p>
<h4 id="f2转化为数组排序">F2：转化为数组排序</h4>
<h5 id="思路-11">思路</h5>
<p>链表无法按照下标访问，只能逐个遍历，因此像排序中的快速排序、堆排序都无法使用，只能使用一次遍历的冒泡排序、选择排序这些。但是这些
<span class="math inline">\(O(n^2)\)</span>
复杂度的排序方法太费时间了，我们可以将其转化成数组后再排序。</p>
<h5 id="步骤-12">步骤</h5>
<ol type="1">
<li>遍历链表，将节点值加入数组。</li>
<li>使用内置的排序函数对数组进行排序。</li>
<li>依次遍历数组和链表，按照位置将链表中的节点值修改为排序后的数组值。</li>
</ol>
<h5 id="代码-13">代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortInList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 遍历链表，将节点值加入数组</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        nums.add(p.val);</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head; <span class="comment">// 重置下标</span></span><br><span class="line">    <span class="comment">// 对数组排序</span></span><br><span class="line">    Collections.sort(nums);</span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        p.val = nums.get(i);</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度-13">时间复杂度</h5>
<p><span class="math inline">\(O(nlog_2n)\)</span></p>
<p>sort 函数一般为优化后的快速排序，复杂度为 <span
class="math inline">\(O(nlog_2n)\)</span>。</p>
<h5 id="空间复杂度-13">空间复杂度</h5>
<p><span class="math inline">\(O(n)\)</span></p>
<p>存储链表元素值的辅助数组长度 n。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>双指针</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
        <tag>牛客-TOP101</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕算法必备技巧（贰） —— 双指针（链表篇）</title>
    <url>/article/631e5355.html</url>
    <content><![CDATA[<p>本文介绍了双指针技巧在链表、数组以及字符串中的使用，给出了大量大厂常见面试手撕题目的思路及代码，不仅适合完全不了解双指针技巧的读者，也适合老司机复习拓展。</p>
<p>考察过该技巧的公司有阿里巴巴、腾讯、美团、拼多多、百度、华为等大厂。</p>
<p>我相信，友好的讨论交流会让彼此快速进步！文章难免有疏漏之处，十分欢迎大家在评论区中批评指正。</p>
<p><strong>食用指南：</strong>
⭐️为一刷必做题，便于快速理解双指针技巧；无星题目可在刷完⭐️题目后再做，用于拓展学习双指针技巧如何与其他算法知识结合使用。</p>
<p><strong>日志更新：</strong>文章底部给出了更新日志，帮助小伙伴们快速知晓最近优化了哪些技巧，更新了哪些题目。</p>
<p>我相信，友好的讨论交流会让彼此快速进步！文章难免有疏漏之处，十分欢迎大家在评论区中批评指正。</p>
<span id="more"></span>
<h1 id="双指针技巧是什么">双指针技巧是什么？</h1>
<p>双指针技巧指的就是在遍历链表、数组或者字符串的过程中，不是使用一个指针来进行访问，而是使用两个指针（甚至可以多个，合并
k 个有序链表中将会用到）进行遍历访问。</p>
<p>以链表为例，两个指针要么<strong>同方向访问两个链表</strong>、要么<strong>同方向访问一个链表（快慢指针）</strong>、要么<strong>相反方向遍历一个链表（左右指针）</strong>，数组和字符串也是如此。</p>
<p>下面，先来看看双指针技巧在链表问题中的应用。我们以题目入手，从易到难，逐步感受双指针技巧的精妙之处。</p>
<p>几乎所有题目都提供了使用双指针技巧的思路，以及动画示意图，希望可以通过这一篇文章让你<strong>彻底弄懂双指针技巧</strong>。</p>
<h1 id="合并与分割类问题">合并与分割类问题</h1>
<h2 id="合并两个有序链表力扣21"><a
href="https://leetcode.cn/problems/merge-two-sorted-lists/">⭐️合并两个有序链表(力扣21)</a></h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305042052248.png" alt="力扣-21-合并两个有序链表" style="zoom:50%;" /></p>
<h3 id="思路双指针">思路(双指针)</h3>
<p>题目中两个链表已经排好序，我们可以使用两个指针同向访问两个链表，每次比较两个指针的元素，谁小谁加到新的链表上。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305032331487.gif" alt="合并两个有序链表"/></p>
<h3 id="参考代码"><strong>参考代码</strong></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">    <span class="comment">// 一条链表为空，必然返回另一条链表，即使另一条链表也为空</span></span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新建一个虚拟头节点(新链表)，后面连接两条链表排序后的节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 三个指针分别指向虚拟头节点，list1，list2</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy, p1 = list1, p2 = list2;</span><br><span class="line">    <span class="comment">// 当两条链表都不为空的时候遍历</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 小的节点加在新链表后面</span></span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt;= p2.val) &#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">            <span class="comment">// 只移动取值的指针</span></span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            <span class="comment">// 新链表指针也要移动</span></span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">            <span class="comment">// 只移动取值的指针</span></span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            <span class="comment">// 新链表指针也要移动</span></span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 哪条链表有剩余(剩余的值一定比前面都大)，就直接连在新链表后面。</span></span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回时去掉虚拟头结点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips</strong></p>
<p>虚拟头节点，即代码中的 <code>dummy</code>
节点。使用虚拟头节点可以避免处理指针 <code>p</code>
为空的情况，降低代码的复杂性。</p>
<p><strong>当我们需要创造一条新链表的时候，可以使用虚拟头节点简化边界情况的处理。</strong>比如本题中两条链表要合并成一条新的有序链表，这时需要创造一条新链表就可以使用。再比如要将一条链表分解成两条链表，这时候要创建两条新链表，也可以使用。</p>
</blockquote>
<h3 id="时间复杂度"><strong>时间复杂度</strong></h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>最坏情况下，遍历两个链表一共 2 * N 个节点</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>无额外辅助空间，返回的链表是原有节点组装，是必要空间。</p>
<hr />
<h2 id="分隔链表力扣86"><a
href="https://leetcode.cn/problems/partition-list/">⭐️分隔链表(力扣86)</a></h2>
<h3 id="题目描述-1">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305040007027.png" alt="力扣-86-分隔链表" style="zoom:50%;" /></p>
<h3 id="思路双指针-1">思路(双指针)</h3>
<p>在上一题中，合并两个有序链表，是将两个有序链表合二为一。而本题是将原链表一分为二，然后再合并成一条链表。具体来说，就是将原链表分成两条小链表，一条链表的元素都小于
x，另一条链表中的元素都大于等于
x，最后将两条链表再拼接到一起就可以了。两条小链表的构建过程就需要用到<strong>「双指针」</strong>技巧。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305061634381.gif"
alt="分割链表" />
<figcaption aria-hidden="true">分割链表</figcaption>
</figure>
<h3 id="参考代码-1">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存放小于 x 的链表的虚拟头节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyLess</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 存放大于等于 x 的链表的虚拟头节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyMore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// p 指针负责遍历原链表，pLess 负责生成小于 x 的结果链表，pMore 负责生成大于等于 x 的结果链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head, pLess = dummyLess, pMore = dummyMore;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123; <span class="comment">// 原链表不为空</span></span><br><span class="line">        <span class="keyword">if</span> (p.val &lt; x) &#123;</span><br><span class="line">            pLess.next = p;</span><br><span class="line">            pLess = pLess.next;    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pMore.next = p;</span><br><span class="line">            pMore = pMore.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// !!! 如果不断开，会成环报错，新手务必注意！</span></span><br><span class="line">        <span class="comment">// 断开原链表中的每个节点的 next 指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nxt</span> <span class="operator">=</span> p.next; <span class="comment">// 记录原链表中当前节点的下个节点</span></span><br><span class="line">        p.next = <span class="literal">null</span>; <span class="comment">// 当前节点的 next 指针设为空</span></span><br><span class="line">        p = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 小 x 链表连接大 x 链表</span></span><br><span class="line">    pLess.next = dummyMore.next;</span><br><span class="line">    <span class="comment">// 返回时去掉虚拟头结点</span></span><br><span class="line">    <span class="keyword">return</span> dummyLess.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips</strong></p>
<p>在循环代码块中，必须断开原链表中每个节点的 next
指针，即将原链表节点的 next 指针设为
null，然后才能向后移动指针，否则就会连接成环从而导致答案错误。</p>
</blockquote>
<h3 id="时间复杂度-1"><strong>时间复杂度</strong></h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>最坏情况下，需要完整遍历一遍原链表。</p>
<h3 id="空间复杂度-1">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>使用了常数个指针，没有额外辅助空间。</p>
<hr />
<h2 id="合并-k-个升序链表力扣23"><a
href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并 K
个升序链表(力扣23)</a></h2>
<h3 id="题目描述-2">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305051038520.png" alt="力扣-23-合并 K 个升序链表" style="zoom:50%;" /></p>
<h3 id="思路k个指针">思路(k个指针)</h3>
<p>我们可以准备 k 个指针，分别放在 k
个链表头，每次取出最小的元素，加入到新的大链表中，指针后移，继续比较，每次出去的都是最小元素，就完成了题目的要求。</p>
<p>在 Java 中，我们可以借助优先级队列 <code>PriorityQueue</code>
来实现。优先级队列本质上是一种堆排序容器，根据传入的比较器确定是大根堆还是小根堆，默认是小根堆。小根堆的堆顶是容器中最小的元素，其余更大的元素在堆下方。想要了解这种结构，可以访问<a
href="https://www.cs.usfca.edu/~galles/visualization/Heap.html">Data
Structure Visualizations</a>网站去查看小根堆的排序过程。</p>
<h3 id="参考代码-2">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span> (lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 优先级队列，小根堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.val - b.val);</span><br><span class="line">    <span class="comment">// 将 k 个链表的头节点加入小根堆</span></span><br><span class="line">    <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">        <span class="comment">// 头节点不为空才能加入</span></span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>)</span><br><span class="line">            pq.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要新建一个结果链表，所以新建一个虚拟头节点，指针 p 用于构建结果链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 取出最小元素的节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        <span class="comment">// 连接到结果链表上</span></span><br><span class="line">        p.next = cur;</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="comment">// 如果被取出的节点后续有节点，加入到小根堆中</span></span><br><span class="line">        <span class="keyword">if</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pq.add(cur.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回时去掉虚拟头节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-2">时间复杂度</h3>
<p><span class="math inline">\(O(nlog_2k)\)</span></p>
<p>n 为所有链表总节点数，最坏要遍历所有节点，每次加入优先级队列排序需要
<span class="math inline">\(O(log_2k)\)</span>。</p>
<h3 id="空间复杂度-2">空间复杂度</h3>
<p><span class="math inline">\(O(k)\)</span></p>
<p>优先队列的大小不会超过 k。</p>
<h2 id="奇偶链表力扣328"><a
href="https://leetcode.cn/problems/odd-even-linked-list/">⭐️奇偶链表(力扣328)</a></h2>
<h3 id="题目描述-3">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305202230733.png" alt="奇偶链表(力扣328)" style="zoom:50%;" /></p>
<h3 id="思路双指针-2">思路(双指针)</h3>
<p>这道题直接使用两个指针同方向遍历链表，第一个节点索引为奇数，第二个节点索引为偶数，第三个节点索引为奇数。我们可以直接断掉节点
1 和节点 2 之间的连接，让节点 1 的 next 指向节点
3，偶数索引节点也是如此。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305202230488.gif"
alt="双指针同向遍历" />
<figcaption aria-hidden="true">双指针同向遍历</figcaption>
</figure>
<h3 id="参考代码-3">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果链表为空，不用重排</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 奇数索引节点指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">odd</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 偶数索引节点指针，可能为空</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">even</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="comment">// 标记偶数索引头节点，用于奇偶索引链表连接</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> even;</span><br><span class="line">    <span class="keyword">while</span> (even != <span class="literal">null</span> &amp;&amp; even.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 奇数索引节点的 next 连向偶数索引节点的下一个</span></span><br><span class="line">        odd.next = even.next;</span><br><span class="line">        <span class="comment">// 奇数索引指针后移</span></span><br><span class="line">        odd = odd.next;</span><br><span class="line">        <span class="comment">// 偶数索引节点的 next 连向奇数索引节点的下一个</span></span><br><span class="line">        even.next = odd.next;</span><br><span class="line">        <span class="comment">// 偶数索引指针后移</span></span><br><span class="line">        even = even.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偶数索引链表连在奇数索引链表后面</span></span><br><span class="line">    odd.next = evenHead;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-3">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>遍历一次链表所有节点。</p>
<h3 id="空间复杂度-3">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，没有额外辅助空间。</p>
<h1 id="快慢指针类问题">快慢指针类问题</h1>
<h2 id="删除链表的倒数第-n-个结点力扣19"><a
href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">⭐️删除链表的倒数第
N 个结点(力扣19)</a></h2>
<h3 id="题目描述-4">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305051340584.png" alt="力扣-19-删除链表的倒数第 N 个结点" style="zoom:50%;" /></p>
<h3 id="思路双指针-3">思路(双指针)</h3>
<p>我们直接讲进阶的实现方式，也就是使用双指针技巧，一趟扫描实现这道题目。</p>
<p>这道题目要用到「双指针」技巧的<strong>「快慢指针」</strong>，假设 n =
3，我们可以先让快指针走 3
步，然后慢指针此时从链表头结点出发，快慢指针同步前进，当快指针走到 null
时，慢指针正好指向要删除的节点。</p>
<p>由于要删除这个节点，我们还需准备一个虚拟头节点，以及一个指向虚拟头节点的指针(前置指针)，前置指针与慢指针同时同步前进，当慢指针指向要删除节点的时候，前置指针正好指向要删除节点的前一个，然后将前置指针的
next 指针指向要删除节点的下一个节点即可。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305051429999.gif"
alt="力扣-19-删除链表的倒数第 N 个结点" />
<figcaption aria-hidden="true">力扣-19-删除链表的倒数第 N
个结点</figcaption>
</figure>
<h3 id="参考代码-4">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 快指针先走 n 步</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给原链表添加一个虚拟头节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">// 准备前置指针和慢指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 前置、快慢指针同步前进，当快指针为空时，慢指针就到了倒数第 n 个位置</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除慢指针处的节点(倒数第 n 个节点)</span></span><br><span class="line">    pre.next = slow.next; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 返回时去掉表头</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-4">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>最坏情况下，遍历 n 个链表节点。</p>
<h3 id="空间复杂度-4">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，无额外辅助空间使用</p>
<hr />
<h2 id="链表的中间结点力扣876"><a
href="https://leetcode.cn/problems/middle-of-the-linked-list/">⭐️链表的中间结点(力扣876)</a></h2>
<h3 id="题目描述-5">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305051443079.png" alt="力扣-876-链表的中间结点" style="zoom:50%;" /></p>
<h3 id="思路双指针-4">思路(双指针)</h3>
<p>这道题用到了「双指针」技巧的
「快慢指针」技巧，我们快慢指针分别指向链表头节点 head。</p>
<p>快指针每次走两步，慢指针每次走一步，当快指针走到链表末尾时，慢指针正好指向链表的中点。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305061630323.gif"
alt="链表的中间节点" />
<figcaption aria-hidden="true">链表的中间节点</figcaption>
</figure>
<h3 id="参考代码-5">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快慢指针分别指向链表头节点 head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">// 快指针走到链表末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 快指针一次走两步，慢指针一次走一步</span></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 慢指针指向链表中点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-5">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<h3 id="空间复杂度-5">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，无额外辅助空间使用。</p>
<h1 id="左右指针类问题">左右指针类问题</h1>
<h2 id="回文链表力扣234"><a
href="https://leetcode.cn/problems/palindrome-linked-list/">⭐️回文链表(力扣234)</a></h2>
<h3 id="题目描述-6">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305101601846.png" alt="回文链表(力扣234)" style="zoom:50%;" /></p>
<h3 id="思路双指针-5">思路(双指针)</h3>
<p>这道题我们直接讲最优方案，也就是时间复杂度为 <span
class="math inline">\(O(n)\)</span>，空间复杂度为 <span
class="math inline">\(O(1)\)</span> 的解题思路。</p>
<p>我们首先使用 <strong>「快慢指针寻中法」</strong> 找到链表的中点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305110028596.png" alt="双指针寻中法" style="zoom:28%;" /></p>
<p>然后反转后半部分的链表，然后重定向「快慢指针」使用
<strong>「左右指针技巧」</strong> 依次比对链表节点值是否相等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305110034658.png" alt="反转链表并重定向快慢指针" style="zoom:28%;" /></p>
<h3 id="参考代码-6">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 空链表为回文链表</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快慢指针寻中法</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中点处反转</span></span><br><span class="line">    slow = reverseList(slow); <span class="comment">// slow 现在指向右半部分的第一个节点</span></span><br><span class="line">    fast = head; <span class="comment">// fast 现在指向左半部分的第一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 比较判断节点值是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (slow.val != fast.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head, succ = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        succ = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = succ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-6">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>双指针找到中点遍历半个链表，后续反转链表为<span
class="math inline">\(O(n)\)</span>，然后再遍历两份半个链表。</p>
<h3 id="空间复杂度-6">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级变量，无额外辅助空间使用。</p>
<h1 id="环形链表类问题">环形链表类问题</h1>
<h2 id="环形链表力扣141"><a
href="https://leetcode.cn/problems/linked-list-cycle/">⭐️环形链表(力扣141)</a></h2>
<h3 id="题目描述-7">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305051657040.png" alt="环形链表(力扣141)" style="zoom:50%;" /></p>
<h3 id="思路双指针-6">思路(双指针)</h3>
<p>这道题用到的也是<strong>「快慢指针」</strong>技巧。<strong>环形链表的环一定在链表末尾，并且末尾没有
null
了</strong>。根据这个特点，我们使用快慢指针同向访问链表，因为速度不一致，如果有环的话，快慢指针一定会相遇；如果没有环的话，快指针一定会遇到空指针。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305051715771.gif"
alt="双指针判断链表是否有环" />
<figcaption aria-hidden="true">双指针判断链表是否有环</figcaption>
</figure>
<h3 id="参考代码-7">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快慢双指针，初始指向链表头 head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 快慢指针移动</span></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇则有环</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快指针走到末尾，则没有环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-7">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>最坏情况下遍历链表 n 个节点。</p>
<h3 id="空间复杂度-7">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>仅使用了两个指针，没有额外辅助空间。</p>
<hr />
<h2 id="环形链表入口节点力扣142"><a
href="https://leetcode.cn/problems/linked-list-cycle-ii/">⭐️环形链表入口节点(力扣142)</a></h2>
<h3 id="题目描述-8">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305051730296.png" alt="环形链表入口节点(力扣142)" style="zoom:50%;" /></p>
<h3 id="思路双指针-7">思路(双指针)</h3>
<p>这道题也是使用「快慢指针」技巧，难点在于如何找到环的入口节点。我会先说如何解决这道题，理论推导过程我也会给出，如果觉得很难懂可以直接跳过，记住解题方法就可以了。</p>
<p>解法就是使用上一题(判断链表是否有环)的方法，找到相遇节点，然后慢指针留在相遇节点，快指针回到链表头节点，之后两个指针同步逐个元素地遍历链表，当两者再次相遇的节点就是环的入口节点。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305051751665.gif"
alt="快慢指针找环入口节点" />
<figcaption aria-hidden="true">快慢指针找环入口节点</figcaption>
</figure>
<p>为什么这样就能找到环的入口节点了呢？</p>
<p>假设在一个有环链表中。快指针在环中走了 <span
class="math inline">\(n\)</span> 圈，慢指针走了 <span
class="math inline">\(m\)</span>
圈，两者相遇。此时，链表头节点到环入口点距离为 <span
class="math inline">\(x\)</span>，环入口到相遇点距离为 <span
class="math inline">\(y\)</span>，相遇点到环入口点距离为 <span
class="math inline">\(z\)</span>。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305051801727.png"
alt="快慢指针相遇时，入口节点为3" />
<figcaption aria-hidden="true">快慢指针相遇时，入口节点为3</figcaption>
</figure>
<p>这个过程中，快指针一共走了 <span class="math inline">\(x + n(y + z) +
y\)</span> 步，慢指针一共走了 <span class="math inline">\(x + m(y + z) +
y\)</span> 步。</p>
<p>快指针走的步数是慢指针的两倍，则 <span class="math display">\[
x + n(y + z) + y = 2(x + m(y + z) + y)
\]</span> 进一步推导 <span class="math display">\[
x+y=(n-2m)(y+z)
\]</span> <span class="math inline">\(y+z\)</span>
就是环的大小，这说明<strong>从链表头经过环入口到达相遇地方经过的距离(x +
y)等于整数倍环的大小(y + z)</strong>。</p>
<p>那么此时，我们从头开始遍历到相遇位置(x +
y)，从相遇位置开始在环中遍历(y +
z)，会使用相同的步数，而<strong>双方最后都会经过入口到相遇位置这 <span
class="math inline">\(y\)</span> 个节点，说明这 <span
class="math inline">\(y\)</span>
个节点它们就是重叠遍历的，那它们从入口位置就相遇了</strong>，这样就找到了入口节点。</p>
<h3 id="参考代码-8">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义快慢双指针，初始化指向链表头节点 head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123; <span class="comment">// 相遇跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳出循环有两种可能</span></span><br><span class="line">    <span class="comment">// 1. 快指针到末尾了，链表无环</span></span><br><span class="line">    <span class="comment">// 2. 链表有环，快慢指针相遇了</span></span><br><span class="line">    <span class="comment">// 情况 2</span></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = head; <span class="comment">// 快指针重新指向头结点</span></span><br><span class="line">        <span class="comment">// 快慢指针同步遍历链表，再次相遇的节点就是环入口节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123; </span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-8">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>最坏情况下遍历链表两次</p>
<h3 id="空间复杂度-8">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>使用了常数个指针，没有额外辅助空间</p>
<hr />
<h2 id="相交链表力扣160"><a
href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">⭐️相交链表(力扣160)</a></h2>
<h3 id="题目描述-9">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305051842006.png" alt="相交链表(力扣160)" style="zoom:50%;" /></p>
<p>这道题就是要寻找到两个链表的第一个公共节点。</p>
<h3 id="思路双指针-8">思路(双指针)</h3>
<p>我们使用两个指针 p1、p2 分别在链表 1、链表 2
上同步前进，但是无法同时走到公共节点。因此，<strong>解决这道题的关键在于，如何能够让两个指针同时到达相交节点
6。</strong></p>
<p>两个指针的速度是一样的，那么如何才能同时到达相同点呢？那么应该要让两个指针走同样的长度。</p>
<p>因此，两个指针一起遍历，如果 p1 先遍历完链表 1 的话，就从链表 2
的头节点继续遍历。同样的，如果 p2 先遍历完链表 2 的话，就从链表 1
的头节点继续遍历。也就是说，p1 和 p2 都会遍历链表 1 和链表 2。</p>
<p>两个指针，同样的速度，走完同样的长度(链表 1 + 链表
2)，不管两条链表有无相同节点，都能够同时到达终点。</p>
<p>也就是说，如果有公共节点，两个指针一定会相遇，相遇节点就是第一个公共节点；如果没有公共节点，两个指针都会走到终点，此时都是
null，也算是相等了。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305051844821.gif"
alt="双指针确定两链表第一个公共节点" />
<figcaption
aria-hidden="true">双指针确定两链表第一个公共节点</figcaption>
</figure>
<h3 id="参考代码-9">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 p1 和 p2 两个指针，分别指向两个链表头</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// 如果 p1 不为空，前进一步，为空则从链表 B 头节点开始</span></span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p1 = headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 p2 不为空，前进一步，为空则从链表 A 头节点开始</span></span><br><span class="line">        <span class="keyword">if</span> (p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p2 = headA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-9">时间复杂度</h3>
<p><span class="math inline">\(O(m+n)\)</span></p>
<p>链表 1 和链表 2 的长度之和。</p>
<h3 id="空间复杂度-9">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，无额外辅助空间使用。</p>
<h1 id="链表反转类问题">链表反转类问题</h1>
<h2 id="反转链表力扣206"><a
href="https://leetcode.cn/problems/reverse-linked-list/">⭐️反转链表(力扣206)</a></h2>
<h3 id="题目描述-10">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305061506639.png" alt="反转链表(力扣206)" style="zoom:50%;" /></p>
<h3 id="思路三指针">思路(三指针)</h3>
<p><strong>反转链表一定要自己在纸上画一遍！</strong></p>
<p>初始化三个指针分别是 pre(黄色)、cur(红色)、nxt(绿色)。</p>
<ul>
<li>pre
指针用于<strong>指向已经反转好的链表的最后一个节点</strong>，最开始没有反转，所以为空。</li>
<li>cur
指针<strong>指向待反转链表(原链表)的第一个节点</strong>，最开始第一个节点待反转，所以指向
head。</li>
<li>nxt
指针<strong>指向待反转链表(原链表)的第二节点，用于保存链表</strong>，因为
cur 的 next 指针指向改变后，后面的链表就失效了，所以需要保存。</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305061651083.gif"
alt="反转链表" />
<figcaption aria-hidden="true">反转链表</figcaption>
</figure>
<h3 id="参考代码-10">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化三个指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head, nxt = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        nxt = cur.next; <span class="comment">// 保存 cur 的下一个节点</span></span><br><span class="line">        cur.next = pre; <span class="comment">// 反转 </span></span><br><span class="line">        <span class="comment">// 指针后移，操作下一个未反转链表的第一个节点</span></span><br><span class="line">        pre = cur; <span class="comment">// 移动 pre 到 cur</span></span><br><span class="line">        cur = nxt; <span class="comment">// 移动 cur 到 nxt</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回反转后的头节点</span></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-10">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>最坏情况下，需要遍历整个链表。</p>
<h3 id="空间复杂度-10">空间复杂度</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，无额外辅助空间使用。</p>
<hr />
<h2 id="链表内指定区间反转力扣92"><a
href="https://leetcode.cn/problems/reverse-linked-list-ii/">⭐️链表内指定区间反转(力扣92)</a></h2>
<h3 id="题目描述-11">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305092248099.png" alt="指定区间反转(力扣92)" style="zoom:50%;" /></p>
<h3 id="思路i双指针">思路I(双指针)</h3>
<p>先说最简单的一种方法，我们找到要反转的链表区间，将这个区间断开，然后利用上一道题的思路反转这个区间链表，然后再重新接上就可以了。这个部分的难点就是要记得保存好一些关键节点，待反转链表的前驱节点，后继节点，待反转链表自己的头节点。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305092304219.gif"
alt="反转指定区间的链表" />
<figcaption aria-hidden="true">反转指定区间的链表</figcaption>
</figure>
<h3 id="参考代码i">参考代码I</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span> <span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义虚拟头节点，便于处理要删除链表第一个节点的情况</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="comment">// 寻找第 m 个节点的前一个节点(待反转链表头节点的前驱节点)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p 抵达第 m 个节点的前一个节点(待反转链表头节点的前驱节点)</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> p;</span><br><span class="line">    <span class="comment">// 寻找第 n 个节点</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存第 n 个节点的下一个节点(待反转链表尾节点的后继节点)</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">succ</span> <span class="operator">=</span> p.next;</span><br><span class="line">    <span class="comment">// 切断待反转链表与后继节点的联系</span></span><br><span class="line">    p.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 待反转链表的头节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> pre.next;</span><br><span class="line">    <span class="comment">// 切断待反转链表头节点与前驱节点的联系</span></span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 前驱节点连接反转后的链表</span></span><br><span class="line">    pre.next = reverse(reverseHead);</span><br><span class="line">    <span class="comment">// 链表反转后，原来的头节点 reverseHead 变成了尾节点，连接后继节点</span></span><br><span class="line">    reverseHead.next = succ;</span><br><span class="line">    <span class="comment">// 返回时去掉虚拟头节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, nxt = <span class="literal">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        nxt = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度i">时间复杂度I</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>遍历一次链表</p>
<h3 id="空间复杂度i">空间复杂度I</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，无额外辅助空间使用。</p>
<h3 id="思路ii双指针头插迭代法">思路II(双指针头插迭代法)</h3>
<p><strong>一定要在纸上画一遍，肯定能够理解代码！</strong></p>
<p>使用双指针，一个指向第 m
个节点，一个指向前驱节点(指针始终不变)。所谓头插法，以图示的 2 到 4
为例，先让 3 号节点插到 2 号节点前面，再让 4 号节点插到 3
号节点前面，这样就反转成功了。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305092346103.gif"
alt="双指针头插迭代法" />
<figcaption aria-hidden="true">双指针头插迭代法</figcaption>
</figure>
<h3 id="参考代码ii">参考代码II</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span> <span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy; <span class="comment">// 永远指向待反转区域的头结点的前驱节点(前一个节点)，循环中永远不变</span></span><br><span class="line">    <span class="comment">// 找到第 m 个节点的前驱节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next; <span class="comment">// 指向待反转区间的头结点</span></span><br><span class="line">    ListNode nxt; <span class="comment">// 永远指向 cur 节点的下一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &lt; n; i++) &#123;</span><br><span class="line">        nxt = cur.next;</span><br><span class="line">        <span class="comment">// 当前节点的下一个节点要前插</span></span><br><span class="line">        cur.next = nxt.next; <span class="comment">// 当前节点的 next 要连接 nxt 的下一个节点 </span></span><br><span class="line">        nxt.next = pre.next; <span class="comment">// nxt 节点，前插到头部，连接原本的头结点(前驱节点的下一个节点)</span></span><br><span class="line">        pre.next = nxt; <span class="comment">// 前驱节点连向 nxt 节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回时去掉虚拟头节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度ii">时间复杂度II</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>最坏情况下，遍历整个链表。</p>
<h3 id="空间复杂度ii">空间复杂度II</h3>
<p><span class="math inline">\(O(1)\)</span></p>
<p>常数级指针变量，无额外辅助空间使用。</p>
<hr />
<h2 id="k-个一组翻转链表力扣25"><a
href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">K
个一组翻转链表(力扣25)</a></h2>
<h3 id="题目描述-12">题目描述</h3>
<p><img src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305101025202.png" alt="K 个一组翻转链表(力扣25)" style="zoom:50%;" /></p>
<h3 id="思路双指针递归">思路(双指针+递归)</h3>
<p>这道题思路很简单，我们只要每轮遍历链表 k 次，分出一组，不足 k
次，不用翻转直接返回这一组的头节点即可。</p>
<p>分出一组后，对这组链表进行翻转，原来的头变成了尾，然后拼接在一起就可以啦。</p>
<p><strong>如何翻转 k 个链表节点呢？</strong></p>
<p>还记得我们之前做过的「反转链表」题目吗？题目的函数签名是
<code>ListNode reverseList(ListNode head)</code>，这个可以理解为「反转
<code>head</code> 到 <code>null</code> 之间的节点」。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head, succ = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        succ = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = succ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>那么如果要翻转 <code>head</code> 到 <code>tail</code>
之间的节点(一共 k 个节点)，要如何做呢？</strong></p>
<p>我们只要更改函数签名
<code>ListNode reverseList(ListNode head, ListNode tail)</code>，将原本代码中的
<code>null</code> 改为 <code>tail</code> 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反转 [head, tail) 的链表节点</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head, succ = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 终止条件从 null 变成 tail</span></span><br><span class="line">    <span class="keyword">while</span> (cur != tail) &#123;</span><br><span class="line">        succ = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = succ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回反转后的头节点</span></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整过程如下。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305101303149.gif"
alt="K 个一组反转链表" />
<figcaption aria-hidden="true">K 个一组反转链表</figcaption>
</figure>
<h3 id="参考代码-11">参考代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间 [pHead, pTail) 有 k 个待反转的节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pHead</span> <span class="operator">=</span> head, pTail = head;</span><br><span class="line">    <span class="comment">// 让 pTail 指向第 k 个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="comment">// 不足 k 个节点，不需要反转，base case</span></span><br><span class="line">        <span class="keyword">if</span> (pTail == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        pTail = pTail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转 k 个节点 </span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(pHead, pTail);</span><br><span class="line">    <span class="comment">// 递归反转后续链表并连接起来</span></span><br><span class="line">    pHead.next = reverseKGroup(pTail, k);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转 [head, tail) 的链表节点</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head, succ = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 终止条件从 null 变成 tail</span></span><br><span class="line">    <span class="keyword">while</span> (cur != tail) &#123;</span><br><span class="line">        succ = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = succ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回反转后的头节点</span></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中 for 循环之后的部分可能需要再解释一下，如图所示：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305101435637.png" /></p>
<p>递归反转并连接后的样子如下：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/mrpersimmon/myblog@master/img/202305101445135.png" /></p>
<h3 id="时间复杂度-11">时间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>遍历链表所有节点</p>
<h3 id="空间复杂度-11">空间复杂度</h3>
<p><span class="math inline">\(O(n)\)</span></p>
<p>递归栈最大深度为 <span class="math inline">\(n/k\)</span></p>
<h1 id="更新日志">更新日志</h1>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>更新时间</th>
<th>更新内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2023.05.06</td>
<td>发布文章，详解双指针技巧，详解 9
道大厂常见手撕题目：合并两个有序链表、分割链表、合并 K
个升序链表、删除链表的倒数第 N
个节点、链表的中间节点、环形链表、环形链表的入口节点、相交链表、反转链表。</td>
</tr>
<tr class="even">
<td>2023.05.09</td>
<td>新增题目：奇偶链表(力扣328)、指定区间反转(力扣92)。</td>
</tr>
<tr class="odd">
<td>2023.05.10</td>
<td>新增食用指南；新增题目：K
个一组翻转链表(力扣25)、回文链表(力扣234)。</td>
</tr>
<tr class="even">
<td>2023.05.11</td>
<td><strong>修改：</strong>更新回文链表(力扣234)图示。</td>
</tr>
<tr class="odd">
<td>2023.05.20</td>
<td><strong>修改：</strong>对所有题目进行分类；修改标题级别。</td>
</tr>
</tbody>
</table>
<h1 id="参考资料">参考资料</h1>
<ol type="1">
<li>牛客网</li>
<li>力扣网</li>
<li>算法基地 - github</li>
<li>labuladong 的算法小抄</li>
<li>代码随想录</li>
<li>draw.io</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
